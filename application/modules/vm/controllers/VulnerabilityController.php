<?php
/**
 * Copyright (c) 2010 Endeavor Systems, Inc.
 *
 * This file is part of OpenFISMA.
 *
 * OpenFISMA is free software: you can redistribute it and/or modify it under the terms of the GNU General Public
 * License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * OpenFISMA is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with OpenFISMA.  If not, see
 * {@link http://www.gnu.org/licenses/}.
 */

/**
 * Controller for Vulnerabilities
 *
 * @author     Andrew Reeves <andrew.reeves@endeavorsystems.com>
 * @copyright  (c) Endeavor Systems, Inc. 2010 {@link http://www.endeavorsystems.com}
 * @license    http://www.openfisma.org/content/license GPLv3
 * @package    Controller
 */
class Vm_VulnerabilityController extends Fisma_Zend_Controller_Action_Object
{
    /**
     * The main name of the model.
     *
     * This model is the main subject which the controller operates on.
     *
     * @var string
     */
    protected $_modelName = 'Vulnerability';

    /**
     * Invokes a contract with Fisma_Zend_Controller_Action_Object regarding privileges
     *
     * @var string
     * @link http://jira.openfisma.org/browse/OFJ-24
     */
    protected $_organizations = '*';

    /**
     * Import scan results via a plug-in
     *
     * @GETAllowed
     * @return void
     */
    public function pluginAction()
    {
        $this->_acl->requirePrivilegeForClass('create', 'Vulnerability');

        // Load the vulnerability plugin form
        $uploadForm = Fisma_Zend_Form_Manager::loadForm('vulnerability_upload');
        $uploadForm = Fisma_Zend_Form_Manager::prepareForm($uploadForm);
        $uploadForm->setAttrib('id', 'injectionForm');

        // Populate the drop menu options
        $networks = Doctrine::getTable('Network')->findAll()->toArray();
        $networkList = array();
        foreach ($networks as $network) {
            $networkList[$network['id']] = $network['nickname'] . ' - ' . $network['name'];
        }
        asort($networkList, SORT_STRING);
        $uploadForm->networkId->addMultiOption('', '');
        $uploadForm->networkId->addMultiOptions($networkList);

        $systems = $this->_me->getSystemsByPrivilege('asset', 'read');
        $selectArray = $this->view->systemSelect($systems);
        $uploadForm->orgSystemId->addMultiOption('', '');
        $uploadForm->orgSystemId->addMultiOptions($selectArray);

        // Configure the file select
        $uploadForm->setAttrib('enctype', 'multipart/form-data');

        // Setup the view
        $this->view->assign('uploadForm', $uploadForm);

        // Handle the file upload, if necessary
        $fileReceived = false;
        $postValues = $this->_request->getPost();
        if ($postValues) {
            if ($uploadForm->isValid($postValues) && $fileReceived = $uploadForm->selectFile->receive()) {
                $filePath = $uploadForm->selectFile->getTransferAdapter()->getFileName('selectFile');
                $values = $uploadForm->getValues();
                $values['filepath'] = $filePath;
                // Execute the plugin with the received file
                try {
                    $plugin = Fisma_Inject_Factory::create(NULL, $values);

                    // get original file name
                    $originalName = pathinfo(basename($filePath), PATHINFO_FILENAME);
                    // organize upload data
                    $upload = new Upload();
                    $upload->userId = $this->_me->id;
                    $upload->save();

                    // parse the file
                    $plugin->parse($upload->id);

                    // add the file to storage
                    $upload->instantiate(array(
                        'tmp_name' => $filePath,
                        'name' => $originalName,
                        'type' => $uploadForm->selectFile->getMimeType()
                    ));

                    $msgs[] = $plugin->getMessages();
                    if (!empty($msgs)) {
                        $this->view->priorityMessenger($msgs);
                    }
                } catch (Fisma_Zend_Exception_InvalidFileFormat $e) {
                    $this->view->priorityMessenger($e->getMessage(), 'warning');
                }
            } else {
                $errorString = Fisma_Zend_Form_Manager::getErrors($uploadForm);

                // Customize the error message
                if ($errorString && stristr($errorString, 'network')) {
                    $msgs[] = array('warning' => 'Network: Value is required and can\'t be empty');
                }

                $file = $_FILES['selectFile'];
                if (Fisma_FileManager::getUploadFileError($file)) {
                    $msgs[] = array('warning' => Fisma_FileManager::getUploadFileError($file));
                }

                if (!$msgs) {
                    $msgs[] = array('notice' => 'An unrecoverable error has occured.');
                }

                // Error message
                $this->view->priorityMessenger($msgs);
            }

            // This is a hack to make the submit button work with YUI:
            /** @yui */ $uploadForm->upload->setValue('Upload');
            $this->render(); // Not sure why this view doesn't auto-render?? It doesn't render when the POST is set.
        }
    }

    /**
     * The preDispatch hook is used to split off poam modify actions, mitigation approval actions, and evidence
     * approval actions into separate controller actions.
     *
     * @return void
     */
    public function preDispatch()
    {
        parent::preDispatch();

        $module = Doctrine::getTable('Module')->findOneByName('Vulnerability Management');

        if (!$module->enabled) {
            throw new Fisma_Zend_Exception('This module is not enabled.');
        }

        $this->_organizations = $this->_me->getOrganizationsByPrivilege('vulnerability', 'read');

        $request = $this->getRequest();
    }

    /**
     * View details of a vulnerability object
     *
     * @GETAllowed
     * @return void
     */
    public function viewAction()
    {
        $id = $this->_request->getParam('id');

        $fromSearchParams = $this->_getFromSearchParams($this->_request);

        $this->view->id = $id;
        $this->_viewVulnerability();
        $vulnerability = $this->view->vulnerability;

        // Load state transition buttons
        $stateTransitionForm = Fisma_Zend_Form_Manager::loadForm('state_transitions');

        $stateTransitionForm->getElement('id')->setValue($id);

        $stateTransitionForm->setDecorators(
            array(
                'FormElements',
                array('HtmlTag', array('tag' => 'span')),
                'Form'
            )
        );

        $stateTransitionForm->setElementDecorators(array('ViewHelper', 'RenderSelf'));

        $resolutions = Doctrine_Query::create()
                       ->from('VulnerabilityResolution vr')
                       ->orderBy('name')
                       ->execute();

        $wontFix = $stateTransitionForm->getElement('wontFix');
        foreach ($resolutions as $resolution) {
            $wontFix->addMultiOption($resolution->id, $this->view->escape($resolution->name));
        }
        // Disable buttons which are disallowed based on current state or user role
        if (!$vulnerability->isValidStateTransition($vulnerability->status, 'FIXED') ||
            !$this->_acl->hasPrivilegeForObject('update', $vulnerability)) {

            $stateTransitionForm->getElement('fixed')->readOnly = true;
        }

        if (!$vulnerability->isValidStateTransition($vulnerability->status, 'WONTFIX') ||
            !$this->_acl->hasPrivilegeForObject('update', $vulnerability)) {

            $stateTransitionForm->getElement('wontFixButton')->setAttrib('disabled', 'true');
        }

        if (!$vulnerability->isValidStateTransition($vulnerability->status, 'OPEN') ||
            !$this->_acl->hasPrivilegeForObject('update', $vulnerability)) {

            $stateTransitionForm->getElement('open')->readOnly = true;
        }

        // Keep url parameters for "Previous" and "Next" buttons
        if (!empty($fromSearchParams)) {
            $action = $stateTransitionForm->getAction();
            $urlPart =  $this->_helper->makeUrlParams($fromSearchParams);
            $action .= $urlPart;
            $stateTransitionForm->setAction($action);
        }

        $this->view->stateTransitionForm = $stateTransitionForm;
        $this->view->toolbarButtons = $this->getToolbarButtons($vulnerability);
        $this->view->searchButtons = $this->getSearchButtons($vulnerability, $fromSearchParams);

        // Put a span around the comment count so that it can be updated from Javascript
        $commentCount = '<span id=\'vulnerabilityCommentsCount\'>' . $vulnerability->getComments()->count() . '</span>';

        $tabView = new Fisma_Yui_TabView('VulnerabilityView', $id);
        $tabView->addTab("Vulnerability $id", "/vm/vulnerability/vulnerability/id/$id");
        $tabView->addTab('Upload History', "/vm/vulnerability/upload-history/id/$id");
        $tabView->addTab("Comments ($commentCount)", "/vm/vulnerability/comments/id/$id");
        $tabView->addTab("Audit Log", "/vm/vulnerability/audit-log/id/$id");

        $this->view->tabView = $tabView;

    }

    /**
     * Override parent in order to disable manual creation of vulnerabilities
     *
     * @GETAllowed
     * @return void
     */
    public function createAction()
    {
        throw new Fisma_Zend_Exception('Manual creation of vulnerabilities is not permitted.');
    }

    /**
     * Override parent in order to disable manual editing of vulnerabilities
     *
     * @GETAllowed
     * @return void
     */
    public function editAction()
    {
        throw new Fisma_Zend_Exception('Manual editing of vulnerabilities is not permitted.');
    }

    /**
     * Add a comment to a specified vulnerability
     *
     */
    public function addCommentAction()
    {
        $id = $this->getRequest()->getParam('id');
        $vulnerability = Doctrine::getTable('Vulnerability')->find($id);

        $this->_acl->requirePrivilegeForObject('update', $vulnerability);

        $comment = $this->getRequest()->getParam('comment');

        if ('' != trim(strip_tags($comment))) {
            $vulnerability->getComments()->addComment($comment);
        } else {
            $this->view->priorityMessenger('Comment field is blank', 'warning');
        }

        $this->_redirect("/vm/vulnerability/view/id/$id");
    }

    /**
     * Display comments for this vulnerability
     *
     * @GETAllowed
     */
    public function commentsAction()
    {
        $id = $this->_request->getParam('id');
        $this->view->assign('id', $id);
        $vulnerability = Doctrine::getTable('Vulnerability')->find($id);

        $this->_viewVulnerability();
        $comments = $vulnerability->getComments()->fetch(Doctrine::HYDRATE_ARRAY);

        $commentRows = array();

        foreach ($comments as $comment) {
            $commentRows[] = array(
                'timestamp' => $comment['createdTs'],
                'username' => $this->view->userInfo($comment['User']['displayName'], $comment['User']['id']),
                'Comment' =>  $this->view->textToHtml($this->view->escape($comment['comment']))
            );
        }

        $dataTable = new Fisma_Yui_DataTable_Local();

        $dataTable->addColumn(
            new Fisma_Yui_DataTable_Column(
                'Timestamp',
                true,
                null,
                null,
                'timestamp'
            )
        );

        $dataTable->addColumn(
            new Fisma_Yui_DataTable_Column(
                'User',
                true,
                'Fisma.TableFormat.formatHtml',
                null,
                'username'
            )
        );

        $dataTable->addColumn(
            new Fisma_Yui_DataTable_Column(
                'Comment',
                false,
                'Fisma.TableFormat.formatHtml',
                null,
                'comment'
            )
        );

        $dataTable->setData($commentRows);

        $this->view->dataTable = $dataTable;

        $commentButton = new Fisma_Yui_Form_Button(
            'commentButton',
            array(
                'label' => 'Add Comment',
                'onClickFunction' => 'Fisma.Commentable.showPanel',
                'onClickArgument' => array(
                    'id' => $id,
                    'type' => 'Vulnerability',
                    'callback' => array(
                        'object' => 'Vulnerability',
                        'method' => 'commentCallback'
                    )
                )
            )
        );

        if (!$this->_acl->hasPrivilegeForObject('comment', $vulnerability)) {
            $commentButton->readOnly = true;
        }

        $this->view->commentButton = $commentButton;
        $this->_helper->layout->setLayout('ajax');
    }

    /**
     * Display basic data about the vulnerability
     *
     * @GETAllowed
     * @return void
     */
    function vulnerabilityAction()
    {
        $this->_viewVulnerability();
        $this->view->keywords = $this->_request->getParam('keywords');
        $this->_helper->layout->setLayout('ajax');

        if ($this->view->vulnerability->status == 'WONTFIX') {
            $id = $this->getRequest()->getParam('id');
            $wontFixQuery = Doctrine_Query::create()
                            ->from('Vulnerability v')
                            ->leftJoin('v.Resolution r')
                            ->where('v.id = ?', $id);
            $status = $wontFixQuery->fetchOne()->Resolution['name'];
            $this->view->wontFixStatus = $status;
        }
        $vulnerability = $this->view->vulnerability;
        $this->view->base = $vulnerability->cvssBaseScore;

        $cvss = new Fisma_Vulnerability_Cvss;

        $this->view->vector = $vulnerability->cvssVector;
        if ($cvss->parseVector($vulnerability->cvssVector)) {
            $cvss->calculate();
            $this->view->baseVectorLabels = $cvss->getBaseVectorLabels();
            $this->view->temporalVectorArray = $cvss->getTemporalVectorArray();
            $this->view->environmentalVectorArray = $cvss->getEnvironmentalVectorArray();
            $this->view->cvss = true;
        } elseif ($vulnerability->cvssBaseScore) {
            $this->view->cvss = true;
            $this->view->vector = 'Not Provided by Scanner';

            $baseVectorLabels = $cvss->getBaseVectorLabels();
            foreach ($baseVectorLabels as &$baseVectorLabel) {
                $baseVectorLabel = 'Unknown';
            }
            $this->view->baseVectorLabels = $baseVectorLabels;
        } else {
            $this->view->cvss = false;
        }

        $discoveredDate = new Zend_Date($vulnerability->discoveredDate, Fisma_Date::FORMAT_DATE);
        $this->view->discoveredDate = $discoveredDate->toString(Fisma_Date::FORMAT_MONTH_DAY_YEAR);

        $createdDate = new Zend_Date($vulnerability->createdTs, Fisma_Date::FORMAT_DATE);
        $this->view->createdTs = $createdDate->toString(Fisma_Date::FORMAT_MONTH_DAY_YEAR);

        if (!is_null($vulnerability->closedTs)) {
            $closedDate = new Zend_Date($vulnerability->closedTs, Fisma_Date::FORMAT_DATE);
            $this->view->closedTs = $closedDate->toString(Fisma_Date::FORMAT_MONTH_DAY_YEAR);
        }
    }

    /**
     * Display the audit log associated with a vulnerability
     *
     * @GETAllowed
     * @return void
     */
    function auditLogAction()
    {
        $this->_viewVulnerability();
        $this->_helper->layout->setLayout('ajax');

        $logs = $this->view->vulnerability->getAuditLog()->fetch(Doctrine::HYDRATE_SCALAR);

        $logRows = array();

        foreach ($logs as $log) {
            $logRows[] = array(
                'timestamp' => $log['o_createdTs'],
                'user' => (empty($log['u_id'])) ? '' : $this->view->userInfo($log['u_displayName'], $log['u_id']),
                'message' => $this->view->textToHtml($this->view->escape($log['o_message']))
            );
        }

        $dataTable = new Fisma_Yui_DataTable_Local();

        $dataTable->addColumn(
            new Fisma_Yui_DataTable_Column(
                'Timestamp',
                true,
                null,
                null,
                'timestamp'
            )
        );

        $dataTable->addColumn(
            new Fisma_Yui_DataTable_Column(
                'User',
                true,
                'Fisma.TableFormat.formatHtml',
                null,
                'username'
            )
        );

        $dataTable->addColumn(
            new Fisma_Yui_DataTable_Column(
                'Message',
                false,
                'Fisma.TableFormat.formatHtml',
                null,
                'message'
            )
        );

        $dataTable->setData($logRows);

        $this->view->dataTable = $dataTable;
    }

    /**
     * Ajax view of the upload history for a vulnerability
     *
     * @GETAllowed
     * @return void
     */
    public function uploadHistoryAction()
    {
        $this->_viewVulnerability();

        $rows = array();
        foreach ($this->view->vulnerability->VulnerabilityUploads as $vUpload) {
            $upload = $vUpload->Upload;
            $user = $upload->User;
            $rows[] = array(
                'date' => $upload->createdTs,
                'user' => $this->view->userInfo($user->displayName, $user->id),
                'action' => ucfirst(strtolower($vUpload->action))
            );
        }

        $this->_helper->layout->setLayout('ajax');

        $dataTable = new Fisma_Yui_DataTable_Local();

        $dataTable->addColumn(
            new Fisma_Yui_DataTable_Column(
                'Date',
                true,
                null,
                null,
                'date'
            )
        );

        $dataTable->addColumn(
            new Fisma_Yui_DataTable_Column(
                'User',
                true,
                'Fisma.TableFormat.formatHtml',
                null,
                'user'
            )
        );

        $dataTable->addColumn(
            new Fisma_Yui_DataTable_Column(
                'Action',
                true,
                null,
                null,
                'action'
            )
        );

        $dataTable->setData($rows);

        $this->view->dataTable = $dataTable;
    }

    private function _viewVulnerability()
    {
        $id = $this->_request->getParam('id');
        $vulnerability = $this->_getSubject($id);

        // Check that the user is permitted to view this vulnerability
        $this->_acl->requirePrivilegeForObject('read', $vulnerability);

        $this->view->vulnerability = $vulnerability;
    }

    /**
     * Change the state of the current vulnerability
     *
     * @return void
     */
    public function changeStateAction()
    {
        $request = $this->getRequest();

        $id = $request->getParam('id');
        $vulnerability = $this->_getSubject($id);

        // The status is sent based on which submit button was clicked
        if ($this->_hasParam('open')) {
            $vulnerability->status = 'OPEN';
        } elseif ($this->_hasParam('fixed')) {
            $vulnerability->status = 'FIXED';
        } elseif ($this->_hasParam('wontFixButton')) {
            $wontFixValue = $request->getParam('wontFix');
            $vulnerability->resolutionId = $wontFixValue;
            $vulnerability->status = 'WONTFIX';
        }

        if ($vulnerability->isModified()) {
            $vulnerability->save();
        }

        // Keep url parameters for "Previous" and "Next" buttons
        $fromSearchParams = $this->_getFromSearchParams($this->_request);
        $fromSearchUrl =  $this->_helper->makeUrlParams($fromSearchParams);

        $this->_redirect("/vm/vulnerability/view/id/$id$fromSearchUrl");
    }

    /**
     * Override to set a better plural name.
     */
    public function getPluralModelName()
    {
        return 'Vulnerabilities';
    }

    /**
     * Override in order to remove the "Create new" button, which does not make sense for vulnerabilities. Instead,
     * add an "upload vulnerabilities" button.
     *
     * @param Fisma_Doctrine_Record $record The object for which this toolbar applies, or null if not applicable
     * @return array Array of Fisma_Yui_Form_Button
     */
    public function getToolbarButtons(Fisma_Doctrine_Record $record = null, $fromSearchUrlParams = null)
    {
        $buttons = parent::getToolbarButtons($record);
        $view = $this->view;

        if (CurrentUser::getInstance()->acl()->hasPrivilegeForClass('create', 'Vulnerability')) {
            $button = new Fisma_Yui_Form_Button_Link(
                'toolbarUploadVulnerabilitiesButton',
                array(
                    'value' => 'Import',
                    'imageSrc' => 'arrowthick-1-n',
                    'href' => '/vm/vulnerability/plugin'
                )
            );

            $buttons['create'] = $button;
        } else {
            if (isset($buttons['create'])) {
                unset($buttons['create']);
            }
        }

        return $buttons;
    }
}
