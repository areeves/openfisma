<?php
/**
 * Copyright (c) 2010 Endeavor Systems, Inc.
 *
 * This file is part of OpenFISMA.
 *
 * OpenFISMA is free software: you can redistribute it and/or modify it under the terms of the GNU General Public 
 * License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * OpenFISMA is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied 
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
 * details.
 *
 * You should have received a copy of the GNU General Public License along with OpenFISMA.  If not, see 
 * {@link http://www.gnu.org/licenses/}.
 */

/**
 * Controller for Vulnerabilities
 *
 * @author     Andrew Reeves <andrew.reeves@endeavorsystems.com>
 * @copyright  (c) Endeavor Systems, Inc. 2010 {@link http://www.endeavorsystems.com}
 * @license    http://www.openfisma.org/content/license GPLv3
 * @package    Controller
 */
class Vm_VulnerabilityController extends Fisma_Zend_Controller_Action_Object
{
    /**
     * The main name of the model.
     * 
     * This model is the main subject which the controller operates on.
     * 
     * @var string
     */
    protected $_modelName = 'Vulnerability';

    /**
     * Invokes a contract with Fisma_Zend_Controller_Action_Object regarding privileges
     * 
     * @var string
     * @link http://jira.openfisma.org/browse/OFJ-24
     */
    protected $_organizations = '*';

    /** 
     * Import scan results via a plug-in
     * 
     * @return void
     */
    public function pluginAction()
    {       
        $this->_acl->requirePrivilegeForClass('create', 'Vulnerability');

        // Load the vulnerability plugin form
        $uploadForm = Fisma_Zend_Form_Manager::loadForm('vulnerability_upload');
        $uploadForm = Fisma_Zend_Form_Manager::prepareForm($uploadForm);
        $uploadForm->setAttrib('id', 'injectionForm');

        // Populate the drop menu options
        $networks = Doctrine::getTable('Network')->findAll()->toArray();
        $networkList = array();
        foreach ($networks as $network) {
            $networkList[$network['id']] = $network['nickname'] . ' - ' . $network['name'];
        }
        asort($networkList, SORT_STRING);
        $uploadForm->network->addMultiOption('', '');
        $uploadForm->network->addMultiOptions($networkList);
        
        // Configure the file select
        $uploadForm->setAttrib('enctype', 'multipart/form-data');
        $uploadForm->selectFile->setDestination(Fisma::getPath('data') . '/uploads/scanreports');

        // Setup the view
        $this->view->assign('uploadForm', $uploadForm);

        // Handle the file upload, if necessary
        $fileReceived = false;
        $postValues = $this->_request->getPost();
        if ($postValues) {
            if ($uploadForm->isValid($postValues) && $fileReceived = $uploadForm->selectFile->receive()) {
                $filePath = $uploadForm->selectFile->getTransferAdapter()->getFileName('selectFile');
                $values = $uploadForm->getValues();
                $values['filepath'] = $filePath;
                // Execute the plugin with the received file
                try {
                    $plugin = Fisma_Inject_Factory::create(NULL, $values);

                    // get original file name
                    $originalName = pathinfo(basename($filePath), PATHINFO_FILENAME);
                    // get current time and set to a format like '20090504_112202'
                    $dateTime = Zend_Date::now()->toString(Fisma_Date::FORMAT_FILENAME_DATETIMESTAMP);
                    // define new file name
                    $newName = str_replace($originalName, $originalName . '_' . $dateTime, basename($filePath));
                    // organize upload data
                    $upload = new Upload();
                    $upload->userId = $this->_me->id;
                    $upload->fileName = $newName;
                    $upload->save();
                    
                    // parse the file
                    $plugin->parse($upload->id);
                    // rename the file by ts
                    rename($filePath, dirname($filePath) . '/' . $newName);

                    $createdWord = ($plugin->created > 1 || $plugin->created === 0) 
                        ?  ' vulnerabilities were' : ' vulnerability was' ;
                    $reopenedWord = ($plugin->reopened > 1 || $plugin->reopened  === 0) 
                        ? ' vulnerabilities were' : ' vulnerability was' ;
                    $suppressedWord = ($plugin->suppressed > 1 || $plugin->suppressed === 0) 
                        ? ' vulnerabilities were' : ' vulnerability was' ;

                    $message = 'Your scan report was successfully uploaded.<br>'
                             . $plugin->created . $createdWord . ' created.<br>'
                             . $plugin->reopened . $reopenedWord . ' reopened.<br>'
                             . $plugin->suppressed . $suppressedWord . ' suppressed.';
                    $this->view->priorityMessenger($message, 'notice');
                } catch (Fisma_Zend_Exception_InvalidFileFormat $e) {
                    $this->view->priorityMessenger($e->getMessage(), 'warning');
                }
            } else {
                $errorString = Fisma_Zend_Form_Manager::getErrors($uploadForm);

                if (!$fileReceived) {
                    $errorString .= "File not received<br>";
                }

                // Error message
                $this->view->priorityMessenger("Scan upload failed:<br>$errorString", 'warning');
            }
            // This is a hack to make the submit button work with YUI:
            /** @yui */ $uploadForm->upload->setValue('Upload');
            $this->render(); // Not sure why this view doesn't auto-render?? It doesn't render when the POST is set.
        }
    }
    
    /**
     * The preDispatch hook is used to split off poam modify actions, mitigation approval actions, and evidence
     * approval actions into separate controller actions.
     * 
     * @return void
     */
    public function preDispatch() 
    {
        parent::preDispatch();

        $module = Doctrine::getTable('Module')->findOneByName('Vulnerability Management');

        if (!$module->enabled) {
            throw new Fisma_Zend_Exception('This module is not enabled.');
        }

        $this->_organizations = $this->_me->getOrganizationsByPrivilege('vulnerability', 'read');

        $request = $this->getRequest();
    }

    /**
     * View details of a vulnerability object
     * 
     * @return void
     */
    public function viewAction()
    {
        $id = $this->_request->getParam('id');

        $vulnerability = $this->_getSubject($id);
        $this->view->vulnerability = $vulnerability;
        
        $this->_acl->requirePrivilegeForObject('read', $vulnerability);

        // Load state transition buttons
        $stateTransitionForm = Fisma_Zend_Form_Manager::loadForm('state_transitions');

        $stateTransitionForm->getElement('id')->setValue($id);

        $stateTransitionForm->setDecorators(
            array(
                'FormElements',
                array('HtmlTag', array('tag' => 'span')),
                'Form'
            )
        );

        $stateTransitionForm->setElementDecorators(array('ViewHelper', 'RenderSelf'));

        $this->view->id = $this->_request->getParam('id');

        $resolutions = Doctrine_Query::create()
                       ->from('VulnerabilityResolution vr')
                       ->orderBy('name')
                       ->execute();

        $wontFix = $stateTransitionForm->getElement('wontFix');
        foreach ($resolutions as $resolution) {
            $wontFix->addMultiOption($resolution->id, $resolution->name);
        }
        // Disable buttons which are disallowed based on current state or user role
        if (!$vulnerability->isValidStateTransition($vulnerability->status, 'FIXED') ||
            !$this->_acl->hasPrivilegeForObject('update', $vulnerability)) {
            
            $stateTransitionForm->getElement('fixed')->readOnly = true;
        }

        if (!$vulnerability->isValidStateTransition($vulnerability->status, 'WONTFIX') ||
            !$this->_acl->hasPrivilegeForObject('update', $vulnerability)) {
            
            $stateTransitionForm->getElement('wontFixButton')->setAttrib('disabled', 'true');
        }

        if (!$vulnerability->isValidStateTransition($vulnerability->status, 'OPEN') ||
            !$this->_acl->hasPrivilegeForObject('update', $vulnerability)) {
            
            $stateTransitionForm->getElement('open')->readOnly = true;
        }
        $this->view->stateTransitionForm = $stateTransitionForm;

        // Put a span around the comment count so that it can be updated from Javascript
        $commentCount = '<span id=\'vulnerabilityCommentsCount\'>' . $vulnerability->getComments()->count() . '</span>';

        $tabView = new Fisma_Yui_TabView('VulnerabilityView', $id);
        $tabView->addTab("Vulnerability $id", "/vm/vulnerability/vulnerability/id/$id");
        $tabView->addTab("CVSS", "/vm/vulnerability/cvss/id/$id");
        $tabView->addTab("Asset", "/vm/vulnerability/asset/id/$id");
        $tabView->addTab('Upload History', "/vm/vulnerability/upload-history/id/$id");
        $tabView->addTab("Comments ($commentCount)", "/vm/vulnerability/comments/id/$id");
        $tabView->addTab("Audit Log", "/vm/vulnerability/audit-log/id/$id");

        $this->view->tabView = $tabView;
    }

    /**
     * Override parent in order to disable manual creation of vulnerabilities
     *
     * @return void
     */
    public function createAction()
    {
        throw new Fisma_Zend_Exception('Manual creation of vulnerabilities is not permitted.');
    }

    /**
     * Override parent in order to disable manual editing of vulnerabilities
     *
     * @return void
     */
    public function editAction()
    {
        throw new Fisma_Zend_Exception('Manual editing of vulnerabilities is not permitted.');
    }

    /**
     * Add a comment to a specified vulnerability
     */
    public function addCommentAction()
    {
        $id = $this->getRequest()->getParam('id');
        $vulnerability = Doctrine::getTable('Vulnerability')->find($id);

        $this->_acl->requirePrivilegeForObject('update', $vulnerability);
        
        $comment = $this->getRequest()->getParam('comment');
        
        if ('' != trim(strip_tags($comment))) {
            $vulnerability->getComments()->addComment($comment);
        } else {
            $this->view->priorityMessenger('Comment field is blank', 'warning');
        }
        
        $this->_redirect("/vm/vulnerability/view/id/$id");
    }

    /**
     * Calculate and display CVSS related information in a tab
     */
    public function cvssAction()
    {
        $this->_helper->layout->setLayout('ajax');
        $id = $this->_request->getParam('id');
        $vulnerability = $this->_getSubject($id);
        $this->view->base = $vulnerability->cvssBaseScore;
        $baseVector = $vulnerability->cvssVector;
        $cvss = new Fisma_Vulnerability_Cvss;
        $this->view->vector = $vulnerability->cvssVector;
        if ($cvss->parseVector($vulnerability->cvssVector)) {
            $cvss->calculate();
            $this->view->baseVectorLabels = $cvss->getBaseVectorLabels();
            $this->view->temporalVectorArray = $cvss->getTemporalVectorArray();
            $this->view->environmentalVectorArray = $cvss->getEnvironmentalVectorArray();
            $this->view->cvss = true;
        } else {
            $this->view->cvss = false;
        }
    }

    /**
     * Display comments for this vulnerability
     */
    public function commentsAction()
    {
        $id = $this->_request->getParam('id');
        $this->view->assign('id', $id);
        $vulnerability = Doctrine::getTable('Vulnerability')->find($id);

        $this->_acl->requirePrivilegeForObject('read', $vulnerability);

        $comments = $vulnerability->getComments()->fetch(Doctrine::HYDRATE_ARRAY);

        $commentButton = new Fisma_Yui_Form_Button(
            'commentButton', 
            array(
                'label' => 'Add Comment', 
                'onClickFunction' => 'Fisma.Commentable.showPanel',
                'onClickArgument' => array(
                    'id' => $id,
                    'type' => 'Vulnerability',
                    'callback' => array(
                        'object' => 'Vulnerability',
                        'method' => 'commentCallback'
                    )
                )
            )
        );

        if (!$this->_acl->hasPrivilegeForObject('comment', $vulnerability)) {
            $commentButton->readOnly = true;
        }

        $this->view->commentButton = $commentButton;
        $this->view->comments = $comments;
        $this->_helper->layout->setLayout('ajax');
    }

    /**
     * Display basic data about the vulnerability
     * 
     * @return void
     */
    function vulnerabilityAction() 
    {
        $this->_viewVulnerability();
        $this->view->keywords = $this->_request->getParam('keywords');
        $this->_helper->layout->setLayout('ajax');

        if ($this->view->vulnerability->status == 'WONTFIX') {
            $id = $this->getRequest()->getParam('id');
            $wontFixQuery = Doctrine_Query::create()
                            ->from('Vulnerability v') 
                            ->leftJoin('v.Resolution r') 
                            ->where('v.id = ?', $id);
            $status = $wontFixQuery->fetchOne()->Resolution['name'];
            $this->view->wontFixStatus = $status;
        }
    }

    /**
     * Display the audit log associated with a vulnerability
     * 
     * @return void
     */
    function auditLogAction() 
    {
        $this->_viewVulnerability();
        $this->_helper->layout->setLayout('ajax');
        
        $logs = $this->view->vulnerability->getAuditLog()->fetch(Doctrine::HYDRATE_SCALAR);
        
        // Convert log messages from plain text to HTML
        foreach ($logs as &$log) {
            $log['o_message'] = $this->view->textToHtml($log['o_message']);
        }

        $this->view->columns = array('Timestamp', 'User', 'Message');
        $this->view->rows = $logs;
    }

    /**
     * Ajax view of the upload history for a vulnerability
     *
     * @return void
     */
    public function uploadHistoryAction()
    {
        $this->_viewVulnerability();
        $rows = array();
        foreach ($this->view->vulnerability->VulnerabilityUploads as $vUpload) {
            $upload = $vUpload->Upload;
            $user = $upload->User;
            $rows[] = array(
                'date' => $upload->createdTs,
                'user' => $this->view->userInfo("{$user->nameFirst} {$user->nameLast}", $user->username),
                'action' => ucfirst(strtolower($vUpload->action))
            );
        }
        $this->view->columns = array('Date', 'User', 'Action');
        $this->view->rows = $rows;
        $this->_helper->layout->setLayout('ajax');
    }

    private function _viewVulnerability()
    {
        $id = $this->_request->getParam('id');
        $vulnerability = $this->_getSubject($id);

        // Check that the user is permitted to view this vulnerability
        $this->_acl->requirePrivilegeForObject('read', $vulnerability);

        $this->view->vulnerability = $vulnerability;
    }

    /**
     * Change the state of the current vulnerability
     *
     * @return void
     */
    public function changeStateAction()
    {
        $request = $this->getRequest();

        $id = $request->getParam('id');
        $vulnerability = $this->_getSubject($id);

        // The status is sent based on which submit button was clicked
        if ($this->_hasParam('open')) {
            $vulnerability->status = 'OPEN';
        } elseif ($this->_hasParam('fixed')) {
            $vulnerability->status = 'FIXED';
        } elseif ($this->_hasParam('wontFixButton')) {
            $wontFixValue = $request->getParam('wontFix');
            $vulnerability->resolutionId = $wontFixValue;
            $vulnerability->status = 'WONTFIX';
        }
        
        if ($vulnerability->isModified()) {
            $vulnerability->save();
        }

        $this->_redirect("/vm/vulnerability/view/id/$id");
    }

    /**
     * Display asset
     *
     * @return void
     */
    public function assetAction()
    {
        $this->_viewVulnerability();
        $this->_helper->layout->setLayout('ajax');
    }

    /**
     * Override to set a better plural name.
     */
    public function getPluralModelName()
    {
        return 'Vulnerabilities';
    }

    /**
     * Override in order to remove the "Create new" button, which does not make sense for vulnerabilities. Instead,
     * add an "upload vulnerabilities" button.
     *
     * @return array Array of Fisma_Yui_Form_Button
     */
    public function getToolbarButtons()
    {
        $buttons = parent::getToolbarButtons();

        if (isset($buttons['create'])) {
            unset($buttons['create']);
        }

        if (CurrentUser::getInstance()->acl()->hasPrivilegeForClass('create', 'Vulnerability')) {
            $buttons['upload'] = new Fisma_Yui_Form_Button_Link(
                'toolbarUploadVulnerabilitiesButton',
                array(
                    'value' => 'Upload Vulnerability Scan',
                    'href' => '/vm/vulnerability/plugin'
                )
            );
        }

        return $buttons;
    }
}
