# ---------------------------------------------------------------------------
# NVD/CVE translator module.
#
# Extracts vulnerability data from National Vulnerability Database data files, 
# in accordance with the format described in
# http://nvd.nist.gov/download/nvdcve.dtd
# ---------------------------------------------------------------------------


package nvd_translation;

#use lib $ENV{'OVMS_ROOT'};

use basic_xml_parser;
use vuln_translator_utils;

use strict;

my $INITIALIZE_OBJECT_FIELDS = 1;



# ---------------------------------------------------------------------------
# Sync up return codes with translation utility module
# ---------------------------------------------------------------------------
my $OK    = $vuln_translator_utils::OK;
my $ERROR = $vuln_translator_utils::ERROR;


# ---------------------------------------------------------------------------
# Sync up message codes with translation utility module
# ---------------------------------------------------------------------------
my $SYS_MSG  = $vuln_translator_utils::SYS_MSG;
my $ERR_MSG  = $vuln_translator_utils::ERR_MSG;
my $WARN_MSG = $vuln_translator_utils::WARN_MSG;
my $INFO_MSG = $vuln_translator_utils::INFO_MSG;
my $DBG_MSG  = $vuln_translator_utils::DBG_MSG;



# ---------------------------------------------------------------------------
# Purpose: Extract vulnerability data from NVD XML source data.
#          Return array of line-by-line vulnerability record data,
#          suitable for use by the injection module.
#
# Input:
#  $input_xml_string - raw NVD XML data to translate
#
#
# Return:
#  $translated_nvd_strings_ref - reference to array of element records, where
#                                an element record is one injectable set of
#                                data fields (e.g.: vulnerability, finding,
#                                solution, etc.)
#  $msg_list_ref - reference to array of error strings generated by
#                    translation process.
# ---------------------------------------------------------------------------
sub translate {
  my ($input_xml_string) = @_;

  my $translated_nvd_strings_ref = [];
  my $msg_list_ref = [];

  my $translation_status; # translate() status
  my $call_status;        # internal calls

  #
  # Perform all processing inside an eval block to catch any fatal
  # utility errors.
  #
  eval {
    #
    # Parse input stream into XML subelement list
    #
    my $xml_subelt_list_ref;
    ($xml_subelt_list_ref, $call_status) = basic_xml_parser::parse($input_xml_string);
    die "FATAL ERROR: Unable to parse input XML" if $call_status != $basic_xml_parser::SUCCESS;

    #
    # For each entry in parsed nvd list
    #
    my $entry_ref_list_ref;
    ($entry_ref_list_ref, $call_status) = basic_xml_parser::children_by_name($xml_subelt_list_ref, "entry");
    die "FATAL ERROR: Unable to retrieve 'entry' elements from XML data" if $call_status != $basic_xml_parser::SUCCESS;

    ENTRY:
    foreach my $entry_ref (@$entry_ref_list_ref) {
      #print "getting one\n";
      #
      # Create vulnerability object
      #
      my $vuln_obj_ref = {}; # hash reference
      if ($INITIALIZE_OBJECT_FIELDS) {
        vuln_translator_utils::initialize_vulnerability_object_fields($vuln_obj_ref);
        }

      #
      # Collect top-level vulnerability stats and description text
      #
      if (get_vulnerability_stats($vuln_obj_ref, $entry_ref, $msg_list_ref) != $OK) {
        my $element_string = vuln_translator_utils::format_xml_as_string($entry_ref);
        push(@$msg_list_ref, ["Unable to collect vulnerability attributes from '$element_string'", $WARN_MSG]);
        next ENTRY;
        }

      if (get_vulnerability_description($vuln_obj_ref, $entry_ref, $msg_list_ref) != $OK) {
        my $element_string = vuln_translator_utils::format_xml_as_string($entry_ref);
        push(@$msg_list_ref, ["Unable to collect vulnerability description '$element_string'", $WARN_MSG]);
        next ENTRY;
        }

      #
      # Generate finding details
      #
      my $finding_obj_ref = {}; # hash reference
      if ($INITIALIZE_OBJECT_FIELDS) {
        vuln_translator_utils::initialize_finding_object_fields($finding_obj_ref);
        }
      if (get_finding_stats($finding_obj_ref, $entry_ref, $msg_list_ref) != $OK) {
        my $element_string = vuln_translator_utils::format_xml_as_string($entry_ref);
        push(@$msg_list_ref, ["Unable to collect finding attributes from '$element_string'", $WARN_MSG]);
        next ENTRY;
        }

      #
      # Collect loss stats
      #
      if (get_loss_stats($vuln_obj_ref, $entry_ref, $msg_list_ref) != $OK) {
        my $element_string = vuln_translator_utils::format_xml_as_string($entry_ref);
        push(@$msg_list_ref, ["Error while collecting loss stats from '$element_string'", $WARN_MSG]);
        next ENTRY;
        }

      #
      # Collect type stats
      #
      if (get_type_stats($vuln_obj_ref, $entry_ref, $msg_list_ref) != $OK) {
        my $element_string = vuln_translator_utils::format_xml_as_string($entry_ref);
        push(@$msg_list_ref, ["Error while collecting type stats from '$element_string'", $WARN_MSG]);
        next ENTRY;
        }

      #
      # Collect range stats
      #
      if (get_range_stats($vuln_obj_ref, $entry_ref, $msg_list_ref) != $OK) {
        my $element_string = vuln_translator_utils::format_xml_as_string($entry_ref);
        push(@$msg_list_ref, ["Error while collecting range stats from '$element_string'", $WARN_MSG]);
        next ENTRY;
        }

      #
      # Get list of solution items
      #
      my $sol_list_ref;
      ($sol_list_ref, $call_status) = get_solution_list($entry_ref, $msg_list_ref);
      if ($call_status != $OK) {
        my $element_string = vuln_translator_utils::format_xml_as_string($entry_ref);
        push(@$msg_list_ref, ["Error while collecting solution list from '$element_string'", $WARN_MSG]);
        next ENTRY;
        }

      #
      # Get list of impact items
      #
      my $impact_list_ref;
      ($impact_list_ref, $call_status) = get_impact_list($entry_ref, $msg_list_ref);
      if ($call_status != $OK) {
        my $element_string = vuln_translator_utils::format_xml_as_string($entry_ref);
        push(@$msg_list_ref, ["Error while collecting solution list from '$element_string'", $WARN_MSG]);
        next ENTRY;
        }

      #
      # Collect software product items
      #
      my $swprod_list_ref;
      ($swprod_list_ref, $call_status) = get_software_product_list($vuln_obj_ref, $entry_ref, $msg_list_ref);
      if ($call_status != $OK) {
        my $element_string = vuln_translator_utils::format_xml_as_string($entry_ref);
        push(@$msg_list_ref, ["Error while collecting software product list from '$element_string'", $WARN_MSG]);
        next ENTRY;
        }

      #
      # Get list of vulnerability reference items
      #
      my $reference_list_ref;
      ($reference_list_ref, $call_status) = get_reference_list($vuln_obj_ref, $entry_ref, $msg_list_ref);
      if ($call_status != $OK) {
        my $element_string = vuln_translator_utils::format_xml_as_string($entry_ref);
        push(@$msg_list_ref, ["Error while collecting reference list from '$element_string'", $WARN_MSG]);
        next ENTRY;
        }


      #
      # Append
      #  vulnerability data
      #  software products
      #  reference items
      # to output string
      #
      my $TRANSLATOR_SOURCE_ID = 'nvd_reader';

      #
      # No finding, related records at this point
      #
      my $related_list_ref = [];

      my $entry_record_list = vuln_translator_utils::format_nonfinding_entry_list($vuln_obj_ref,
                                                                                  $related_list_ref,
                                                                                  $sol_list_ref,
                                                                                  $impact_list_ref,
                                                                                  $swprod_list_ref,
                                                                                  $reference_list_ref,
                                                                                  $msg_list_ref);
      push(@$translated_nvd_strings_ref, @$entry_record_list);
      }
    };
  if ($@) {
    push(@$msg_list_ref, ["FATAL PROCESSING ERROR: $@", $ERR_MSG]);
    $translation_status = $ERROR;
    }

  #log_errors($msg_list_ref);

  return ($translated_nvd_strings_ref, $msg_list_ref);
}


sub get_vulnerability_stats {
  my ($vuln_obj_ref, $entry_xml_ref, $msg_list_ref) = @_;

  my $status = $OK;
  my $rex_status;

  #
  # Link attribute names to object keys so the code can just spin
  # through the attribute extractions.
  # Each key in this lookup maps to a vulnerability object hash key.
  # Each value maps to the associated attribute name in the source XML.
  #
  my %vuln_attr_lookups = (
    $vuln_translator_utils::VULN_CVENAME  => 'name',
    $vuln_translator_utils::VULN_DT_DISCV => 'discovered',
    $vuln_translator_utils::VULN_DT_PUB   => 'published',
    $vuln_translator_utils::VULN_DT_MOD   => 'modified',
    $vuln_translator_utils::VULN_VULN_SEV => 'severity',
    );

  #
  # Get top-level vulnerability entry attributes
  #  run through object/attribute name keys
  #
  if (vuln_translator_utils::map_attrs_to_object($entry_xml_ref, $vuln_obj_ref, \%vuln_attr_lookups, $vuln_translator_utils::ELEMENT_NONEXISTENCE_VALUE, $msg_list_ref) != $OK) {
    push(@$msg_list_ref, ["get_vulnerability_stats - error getting attribute", $WARN_MSG]);
    return $ERROR;
    }

  #
  # See if CVSS_score (31 Jan 2006) is available for this scan/result,
  #  use that value for severity if found.
  #
  my $cvss_score;
  ($cvss_score, $rex_status) = basic_xml_parser::attribute_by_name($entry_xml_ref, 'CVSS_score');
  if ($rex_status == $basic_xml_parser::SUCCESS) {
    $vuln_obj_ref->{$vuln_translator_utils::VULN_VULN_SEV} = $cvss_score;
    }

  #
  # Update severity value to get it into the 0-100 range.
  # If the new CVSS_score field is not yet available for the
  #  results being scanned, convert the Low/Medium/High tag to
  #  a number.
  # If the 0-10 CVSS_score has been retrieved, convert that value
  #  to the 0-100 range.
  #
  $vuln_obj_ref->{$vuln_translator_utils::VULN_VULN_SEV} = translate_severity($vuln_obj_ref->{$vuln_translator_utils::VULN_VULN_SEV});

  return $status;
}

sub get_vulnerability_description {
  my ($vuln_obj_ref, $entry_xml_ref, $msg_list_ref) = @_;

  my $status = $OK;
  my $rex_status;

  #
  # Get descript child element
  #
  my $descript_elt_ref;
  ($descript_elt_ref, $rex_status) = basic_xml_parser::first_child_by_name($entry_xml_ref, 'descript');
  if ($rex_status != $basic_xml_parser::SUCCESS) {
    push(@$msg_list_ref, ["get_vulnerability_description - error getting 'descript' child element", $WARN_MSG]);
    return $ERROR;
    }

  #
  # Determine source
  #
  my $source_val;
  ($source_val, $rex_status) = basic_xml_parser::attribute_by_name($descript_elt_ref, 'source');
  if ($rex_status != $basic_xml_parser::SUCCESS) {
    push(@$msg_list_ref, ["get_vulnerability_description - unable to retrieve 'source' attribute from 'descript' child element", $WARN_MSG]);
    return $ERROR;
    }

  #
  # Get description text data
  #
  my $desc_text;
  ($desc_text, $rex_status) = basic_xml_parser::deep_data($descript_elt_ref);
  if ($rex_status != $basic_xml_parser::SUCCESS) {
    push(@$msg_list_ref, ["get_vulnerability_description - unable to retrieve text data  from 'descript' child element", $WARN_MSG]);
    return $ERROR;
    }

  #
  # Initialize vulnerability fields
  #
  my @vulnerability_fields = (
    $vuln_translator_utils::VULN_DESC_PRIMARY,
    $vuln_translator_utils::VULN_DESC_SECONDARY,
    );
  foreach my $vulnerability_field (@vulnerability_fields) {
    $vuln_obj_ref->{$vulnerability_field} = $vuln_translator_utils::NONEXISTENT_ELEMENT_TEXT_VALUE;
    }

  #
  # Set proper vulnerability field based on source
  #
  my %vuln_desc_field_lookup = (
    'cve' => $vuln_translator_utils::VULN_DESC_PRIMARY,
    'nvd' => $vuln_translator_utils::VULN_DESC_SECONDARY,
    );

  #print "$vuln_translator_utils::VULN_DESC_CVE, $vuln_translator_utils::VULN_DESC_NVD\n";

  my $vuln_field = $vuln_desc_field_lookup{$source_val};

  if (defined($vuln_field)) {
    $vuln_obj_ref->{$vuln_field} = $desc_text;
    }
  else {
    push(@$msg_list_ref, ["get_vulnerability_description - 'descript' 'source' attribute value '$source_val' not valid", $WARN_MSG]);
    return $ERROR;
    }

  return $status;
}


sub get_finding_stats {
  my ($finding_obj_ref, $entry_xml_ref, $msg_list_ref) = @_;

  my $NVD_READER_TAG = 'nvd_reader';

  my $status = $OK;

  #
  # Simply record that this is the nvd reader
  #
  vuln_translator_utils::record_absent_finding_elt($finding_obj_ref);
  $finding_obj_ref->{$vuln_translator_utils::FIND_SOURCEID} = $NVD_READER_TAG;

  return $status;
}

sub get_loss_stats {
  my ($vuln_obj_ref, $entry_xml_ref, $msg_list_ref) = @_;

  my $status = $OK;
  my $rex_status;

  #
  # Initialize loss element fields to non-existent
  #
  vuln_translator_utils::record_absent_loss_elt($vuln_obj_ref);

  #
  # Get loss element or return
  #
  my ($loss_elt_ref, $child_status) = vuln_translator_utils::get_child_element($entry_xml_ref, 'loss_types');
  return $child_status if (!defined($loss_elt_ref));


  #
  # Get avail element
  # Get conf element
  # Get int element
  #
  # Link child element to object keys so the code can just spin
  # through the child existence check.
  # Each key in this lookup maps to a vulnerability object hash key.
  # Each value maps to the associated child element name in the source XML.
  #
  my %loss_elt_lookups = (
    $vuln_translator_utils::VULN_LOSS_AVAIL  => 'avail',
    $vuln_translator_utils::VULN_LOSS_CONFID => 'conf',
    $vuln_translator_utils::VULN_LOSS_INTEG  => 'int',
    );

  #
  # Check for simple existence of these elts
  #
  if (vuln_translator_utils::map_value_to_child_existence($loss_elt_ref,
                                                          $vuln_obj_ref,
                                                          \%loss_elt_lookups,
                                                          $vuln_translator_utils::ELEMENT_EXISTENCE_VALUE,
                                                          $vuln_translator_utils::ELEMENT_NONEXISTENCE_VALUE,
                                                          $msg_list_ref)
                                                          != $OK) {
    push(@$msg_list_ref, ["get_loss_stats - error checking for child existence", $WARN_MSG]);
    return $ERROR;
    }

  #
  # Get sec_prot element, admin/user/other attributes
  #
  my $sec_prot_elt_ref;
  ($sec_prot_elt_ref, $rex_status) = basic_xml_parser::first_child_by_name($loss_elt_ref, 'sec_prot');
  if ($rex_status != $basic_xml_parser::SUCCESS &&
      $rex_status != $basic_xml_parser::NO_MATCH) {
    push(@$msg_list_ref, ["get_loss_stats - error getting 'sec_prot' child element", $WARN_MSG]);
    return $ERROR;
    }

  my %sec_prot_attr_lookups = (
    $vuln_translator_utils::VULN_LOSS_SEC_ADM   => 'admin',
    $vuln_translator_utils::VULN_LOSS_SEC_USER  => 'user',
    $vuln_translator_utils::VULN_LOSS_SEC_OTHER => 'other',
    );

  if (vuln_translator_utils::map_attrs_to_object($sec_prot_elt_ref, $vuln_obj_ref, \%sec_prot_attr_lookups, $vuln_translator_utils::ELEMENT_NONEXISTENCE_VALUE, $msg_list_ref) != $OK) {
    push(@$msg_list_ref, ["get_loss_stats - error getting attribute", $WARN_MSG]);
    return $ERROR;
    }



  return $status;
}

sub get_type_stats {
  my ($vuln_obj_ref, $entry_xml_ref, $msg_list_ref) = @_;

  my $status = $OK;
  my $rex_status;

  #
  # Initialize type element fields to non-existent
  #
  vuln_translator_utils::record_absent_type_elt($vuln_obj_ref);

  #
  # Get vuln_types element or return
  #
  my ($vuln_types_elt_ref, $child_status) = vuln_translator_utils::get_child_element($entry_xml_ref, 'vuln_types');
  return $child_status if (!defined($vuln_types_elt_ref));

  #
  # Get input child, bound and buffer attributes
  #
  my $input_elt_ref;
  ($input_elt_ref, $rex_status) = basic_xml_parser::first_child_by_name($entry_xml_ref, 'input');
  if ($rex_status != $basic_xml_parser::SUCCESS &&
      $rex_status != $basic_xml_parser::NO_MATCH) {
    push(@$msg_list_ref, ["get_type_stats - error getting 'input' child element", $WARN_MSG]);
    return $ERROR;
    }

  #
  # If there's an input elt, extract the bound/buffer attributes
  #
  if ($rex_status == $basic_xml_parser::SUCCESS) {
    my %input_attr_lookups = (
      $vuln_translator_utils::VULN_TYPE_INPUT_BOUND => 'bound',
      $vuln_translator_utils::VULN_TYPE_INPUT_BUFF  => 'buffer',
      );

    if (vuln_translator_utils::map_attrs_to_object($input_elt_ref, $vuln_obj_ref, \%input_attr_lookups, $vuln_translator_utils::ELEMENT_NONEXISTENCE_VALUE, $msg_list_ref) != $OK) {
      push(@$msg_list_ref, ["get_type_stats - error getting attribute", $WARN_MSG]);
      return $ERROR;
      }

    #
    # Confirm that there exists an input element
    #
    $vuln_obj_ref->{$vuln_translator_utils::VULN_TYPE_INPUT} = $vuln_translator_utils::ELEMENT_EXISTENCE_VALUE;
    }

  #
  # Get access child
  # Get design child
  # Get exception child
  # Get env child
  # Get config child
  # Get race child
  # Get other child
  #
  # Link child element to object keys so the code can just spin
  # through the child existence check.
  # Each key in this lookup maps to a vulnerability object hash key.
  # Each value maps to the associated child element name in the source XML.
  #
  my %vuln_type_child_lookups = (
    $vuln_translator_utils::VULN_TYPE_ACCESS => 'access',
    $vuln_translator_utils::VULN_TYPE_DESIGN => 'design',
    $vuln_translator_utils::VULN_TYPE_EXCEPT => 'exception',
    $vuln_translator_utils::VULN_TYPE_ENV    => 'env',
    $vuln_translator_utils::VULN_TYPE_CONFIG => 'config',
    $vuln_translator_utils::VULN_TYPE_RACE   => 'race',
    $vuln_translator_utils::VULN_TYPE_OTHER  => 'other',
    );

  #
  # Check for simple existence of these elts
  #
  if (vuln_translator_utils::map_value_to_child_existence($vuln_types_elt_ref, 
                                                          $vuln_obj_ref,
                                                          \%vuln_type_child_lookups, 
                                                          $vuln_translator_utils::ELEMENT_EXISTENCE_VALUE,
                                                          $vuln_translator_utils::ELEMENT_NONEXISTENCE_VALUE,
                                                          $msg_list_ref) != $OK) {
    push(@$msg_list_ref, ["get_type_stats - error checking for child existence", $WARN_MSG]);
    return $ERROR;
    }

  return $status;
}


sub get_range_stats {
  my ($vuln_obj_ref, $entry_xml_ref, $msg_list_ref) = @_;

  my $status = $OK;

  #
  # Initialize range element fields to non-existent
  #
  vuln_translator_utils::record_absent_range_elt($vuln_obj_ref);

  #
  # Get range element or return
  #
  my ($range_elt_ref, $child_status) = vuln_translator_utils::get_child_element($entry_xml_ref, 'range');
  return $child_status if (!defined($range_elt_ref));

  #
  # Get local child
  # Get remote child
  # Get user_init child
  #
  my %range_child_lookups = (
    $vuln_translator_utils::VULN_RANGE_LOCAL  => 'local',
    $vuln_translator_utils::VULN_RANGE_REMOTE => 'remote',
    $vuln_translator_utils::VULN_RANGE_USER   => 'user_init',
    );

  if (vuln_translator_utils::map_value_to_child_existence($range_elt_ref, 
                                                          $vuln_obj_ref, 
                                                          \%range_child_lookups,
                                                          $vuln_translator_utils::ELEMENT_EXISTENCE_VALUE,
                                                          $vuln_translator_utils::ELEMENT_NONEXISTENCE_VALUE, 
                                                          $msg_list_ref) 
                                                          != $OK) {
    push(@$msg_list_ref, ["get_range_stats - error checking for child existence", $WARN_MSG]);
    return $ERROR;
    }

  return $status;
}

sub get_software_product_list {
  my ($vuln_obj_ref, $entry_xml_ref, $msg_list_ref) = @_;

  my $status = $OK;
  my $rex_status;

  #
  # Initialize product return list
  #
  my $product_list_ref = [];

  #
  # Get vuln_soft child element or return
  #
  my ($vuln_soft_elt_ref, $child_status) = vuln_translator_utils::get_child_element($entry_xml_ref, 'vuln_soft');
  return (undef, $child_status) if (!defined($vuln_soft_elt_ref));

  my $prod_ref_list_ref;
  ($prod_ref_list_ref, $rex_status) = basic_xml_parser::children_by_name($vuln_soft_elt_ref, 'prod');
  if ($rex_status != $basic_xml_parser::SUCCESS &&
      $rex_status != $basic_xml_parser::NO_MATCH) {
    push(@$msg_list_ref, ["get_software_product_list - error getting 'prod' children", $WARN_MSG]);
    return (undef, $ERROR);
    }

  #
  # For each prod child element
  #
  foreach my $prod_elt_ref (@$prod_ref_list_ref) {
    #
    # Get vendor attribute
    #
    my $vendor_val;
    ($vendor_val, $rex_status) = basic_xml_parser::attribute_by_name($prod_elt_ref, 'vendor');
    if ($rex_status != $basic_xml_parser::SUCCESS) {
      push(@$msg_list_ref, ["get_software_product_list - unable to retrieve 'vendor' attribute from 'prod' element", $WARN_MSG]);
      return (undef, $ERROR);
      }

    #
    # Get name attribute
    #
    my $name_val;
    ($name_val, $rex_status) = basic_xml_parser::attribute_by_name($prod_elt_ref, 'name');
    if ($rex_status != $basic_xml_parser::SUCCESS) {
      push(@$msg_list_ref, ["get_software_product_list - unable to retrieve 'name' attribute from 'prod' element", $WARN_MSG]);
      return (undef, $ERROR);
      }

    #
    # For each vers child object
    #
    my $vers_ref_list_ref;
    ($vers_ref_list_ref, $rex_status) = basic_xml_parser::children_by_name($prod_elt_ref, 'vers');
    if ($rex_status != $basic_xml_parser::SUCCESS &&
        $rex_status != $basic_xml_parser::NO_MATCH) {
      push(@$msg_list_ref, ["get_software_product_list - error getting 'vers' children", $WARN_MSG]);
      return (undef, $ERROR);
      }

    foreach my $vers_elt_ref (@$vers_ref_list_ref) {
      #
      # Create new product hash object (reference),
      #  set vendor, name
      #
      my $swprod_obj_ref = {};
      if ($INITIALIZE_OBJECT_FIELDS) {
        vuln_translator_utils::initialize_swprod_object_fields($swprod_obj_ref);
        }

      $swprod_obj_ref->{$vuln_translator_utils::SWPROD_VENDOR} = $vendor_val;
      $swprod_obj_ref->{$vuln_translator_utils::SWPROD_NAME}   = $name_val;

      #
      # Store version number, prev attribute
      #
      my %vers_attr_lookups = (
        $vuln_translator_utils::SWPROD_VERSION => 'num',
        $vuln_translator_utils::SWPROD_PREV    => 'prev',
        );

      if (vuln_translator_utils::map_attrs_to_object($vers_elt_ref, $swprod_obj_ref, \%vers_attr_lookups, $vuln_translator_utils::ELEMENT_NONEXISTENCE_VALUE, $msg_list_ref) != $OK) {
        push(@$msg_list_ref, ["get_software_product_list - error getting vers element attribute", $WARN_MSG]);
        return (undef, $ERROR);
        }

      #
      # NVD in this case means NVD product injection, not CVE list.
      # So it's false. Now.
      #
      $swprod_obj_ref->{$vuln_translator_utils::SWPROD_NVD_CREATED} = 1;

      #
      # Meta is combination of vendor, product, version
      #
      my $metadata = "$swprod_obj_ref->{$vuln_translator_utils::SWPROD_VENDOR} $swprod_obj_ref->{$vuln_translator_utils::SWPROD_NAME} $swprod_obj_ref->{$vuln_translator_utils::SWPROD_VERSION}";
      $swprod_obj_ref->{$vuln_translator_utils::SWPROD_META} = $metadata;

      #
      # Description is blank right now
      #
      $swprod_obj_ref->{$vuln_translator_utils::SWPROD_DESC} = $vuln_translator_utils::NONEXISTENT_ELEMENT_TEXT_VALUE;

      #
      # Add hash ref to return list
      #
      push(@$product_list_ref, $swprod_obj_ref);
      }
    }

  return ($product_list_ref, $status);
}

sub get_reference_list {
  my ($vuln_obj_ref, $entry_xml_ref, $msg_list_ref) = @_;

  my $status = $OK;
  my $rex_status;

  #
  # Initialize list of ref objects
  #
  my $reference_list_ref = [];

  #
  # For each ref child object
  #
  my $ref_list_ref;
  ($ref_list_ref, $rex_status) = basic_xml_parser::children_by_name($entry_xml_ref, 'ref');
  if ($rex_status != $basic_xml_parser::SUCCESS &&
      $rex_status != $basic_xml_parser::NO_MATCH) {
    push(@$msg_list_ref, ["get_reference_list - error getting 'ref' children", $WARN_MSG]);
    return (undef, $ERROR);
    }

  foreach my $ref_elt_ref (@$ref_list_ref) {
    #
    # Create new ref object hash (reference)
    #
    my $ref_obj_ref = {};
    if ($INITIALIZE_OBJECT_FIELDS) {
      vuln_translator_utils::initialize_ref_object_fields($ref_obj_ref);
      }

    #
    # Store source, url, sig, adv, patch attributes
    #
    my %ref_attr_lookups = (
      $vuln_translator_utils::REF_SOURCE    => 'source',
      $vuln_translator_utils::REF_URL       => 'url',
      $vuln_translator_utils::REF_HAS_SIG   => 'sig',
      $vuln_translator_utils::REF_IS_ADV    => 'adv',
      $vuln_translator_utils::REF_HAS_PATCH => 'patch',
      );

    if (vuln_translator_utils::map_attrs_to_object($ref_elt_ref, $ref_obj_ref, \%ref_attr_lookups, $vuln_translator_utils::ELEMENT_NONEXISTENCE_VALUE, $msg_list_ref) != $OK) {
      push(@$msg_list_ref, ["get_reference_list - error getting ref element attribute", $WARN_MSG]);
      return (undef, $ERROR);
      }

    #
    # Store text data
    #
    my $ref_text;
    ($ref_text, $rex_status) = basic_xml_parser::deep_data($ref_elt_ref);
    if ($rex_status != $basic_xml_parser::SUCCESS) {
      push(@$msg_list_ref, ["get_reference_list - unable to retrieve text data from 'ref' element", $WARN_MSG]);
      return (undef, $ERROR);
      }

    $ref_obj_ref->{$vuln_translator_utils::REF_NAME} = $ref_text;

    #
    # Add new ref obj reference to ref list
    #
    push(@$reference_list_ref, $ref_obj_ref);
    }

  return ($reference_list_ref, $status);
}


sub get_solution_list {
  my ($entry_xml_ref, $msg_list_ref) = @_;

  my $status = $OK;
  my $rex_status;

  #
  # Initialize list of objects
  #
  my $solution_list_ref = [];

  #
  # For each sol child object
  #
  my $sol_list_ref;
  ($sol_list_ref, $rex_status) = basic_xml_parser::children_by_name($entry_xml_ref, 'sol');
  if ($rex_status != $basic_xml_parser::SUCCESS &&
      $rex_status != $basic_xml_parser::NO_MATCH) {
    push(@$msg_list_ref, ["get_solution_list - error getting 'sol' children", $WARN_MSG]);
    return (undef, $ERROR);
    }

  foreach my $sol_elt_ref (@$sol_list_ref) {
    #
    # Create new solution object hash (reference)
    #
    my $sol_obj_ref = {};
    if ($INITIALIZE_OBJECT_FIELDS) {
      vuln_translator_utils::initialize_sol_object_fields($sol_obj_ref);
      }

    #
    # Retrieve 'source' attribute
    #
    my %sol_attr_lookups = (
      $vuln_translator_utils::SOL_SOURCE => 'source',
      );

    if (vuln_translator_utils::map_attrs_to_object($sol_elt_ref, $sol_obj_ref, \%sol_attr_lookups, $vuln_translator_utils::ELEMENT_NONEXISTENCE_VALUE, $msg_list_ref) != $OK) {
      push(@$msg_list_ref, ["get_solution_list - error getting attribute", $WARN_MSG]);
      return $ERROR;
      }

    #
    # Retrieve description text data
    #
    my $sol_text;
    ($sol_text, $rex_status) = basic_xml_parser::deep_data($sol_elt_ref);
    if ($rex_status != $basic_xml_parser::SUCCESS) {
      push(@$msg_list_ref, ["get_solution_list - unable to retrieve text data from 'sol' element", $WARN_MSG]);
      return (undef, $ERROR);
      }

    $sol_obj_ref->{$vuln_translator_utils::SOL_DESC} = $sol_text;

    #
    # Add object to list
    #
    push(@$solution_list_ref, $sol_obj_ref);
    }

  return ($solution_list_ref, $status);
}


sub get_impact_list {
  my ($entry_xml_ref, $msg_list_ref) = @_;

  my $status = $OK;
  my $rex_status;

  #
  # Initialize list of objects
  #
  my $impact_list_ref = [];

  #
  # For each impact child object
  #
  my $impact_list_ref;
  ($impact_list_ref, $rex_status) = basic_xml_parser::children_by_name($entry_xml_ref, 'impact');
  if ($rex_status != $basic_xml_parser::SUCCESS &&
      $rex_status != $basic_xml_parser::NO_MATCH) {
    push(@$msg_list_ref, ["get_impact_list - error getting 'impact' children", $WARN_MSG]);
    return (undef, $ERROR);
    }

  foreach my $impact_elt_ref (@$impact_list_ref) {
    #
    # Create new solution object hash (reference)
    #
    my $impact_obj_ref = {};
    if ($INITIALIZE_OBJECT_FIELDS) {
      vuln_translator_utils::initialize_impact_object_fields($impact_obj_ref);
      }

    #
    # Retrieve 'source' attribute
    #
    my %impact_attr_lookups = (
      $vuln_translator_utils::IMPACT_SOURCE => 'source',
      );

    if (vuln_translator_utils::map_attrs_to_object($impact_elt_ref, $impact_obj_ref, \%impact_attr_lookups, $vuln_translator_utils::ELEMENT_NONEXISTENCE_VALUE, $msg_list_ref) != $OK) {
      push(@$msg_list_ref, ["get_impact_list - error getting attribute", $WARN_MSG]);
      return $ERROR;
      }

    #
    # Retrieve description text data
    #
    my $impact_text;
    ($impact_text, $rex_status) = basic_xml_parser::deep_data($impact_elt_ref);
    if ($rex_status != $basic_xml_parser::SUCCESS) {
      push(@$msg_list_ref, ["get_impact_list - unable to retrieve text data from 'impact' element", $WARN_MSG]);
      return (undef, $ERROR);
      }

    $impact_obj_ref->{$vuln_translator_utils::IMPACT_DESC} = $impact_text;

    #
    # Add object to list
    #
    push(@$impact_list_ref, $impact_obj_ref);
    }

  return ($impact_list_ref, $status);
}



sub log_errors {
  my ($msg_list_ref) = @_;

  foreach my $error_string (@$msg_list_ref) {
    print "$error_string->[0]\n";
    }
}


# template - remove
sub get_vulnerability_ {
  my ($vuln_obj_ref, $entry_xml_ref) = @_;

  my $status = $OK;

  return $status;
}


#
# Map severity string to level between 0 and 100
#
my %severity_for = (
  'High'   => $vuln_translator_utils::HIGH_SEVERITY,
  'Medium' => $vuln_translator_utils::MEDIUM_SEVERITY,
  'Low'    => $vuln_translator_utils::LOW_SEVERITY,
  );

sub translate_severity {
  my ($severity_str, $msg_list_ref) = @_;
  
  my $severity_val;
  #print "str $severity_str\n";
  
  #
  # If severity is coming in as a number from 1 to 10
  #
  #if ($severity_str >= 0 && $severity_str <= 10) {
  if ($severity_str =~ m{\d+(\.\d*)?}) {
  #print "is number $severity_str\n";
    #
    # Get it into 0 to 100 scale
    #
    $severity_val = $severity_str * 10;
    }
  else {
    #
    # Otherwise map qualitative string to a number
    #
    if (defined($severity_for{$severity_str})) {
      $severity_val = $severity_for{$severity_str};
      #print "translate_severity: $severity_val\n";
      }
    else {
      $severity_val = $vuln_translator_utils::DEFAULT_SEVERITY;
      push(@$msg_list_ref, ["translate_severity - unable to map severity for '$severity_str', setting severity to $severity_val", $WARN_MSG]);
      #print "nothing: $severity_val\n";
      }
    }
  
  return ($severity_val);
}

1;