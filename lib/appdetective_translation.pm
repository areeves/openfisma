# ---------------------------------------------------------------------------
# AppDetective translator module.
#
# This translator works on the 'Vulnerability Details Report' XML data file 
# generated by AppDetective.
#
# The 'data' element in the XML data contains information that roughly 
# corresponds to a vulnerability, followed by one or more 'details'
# elements which give finding instance information.
#
# The mapping from XML to database injection fields is as follows:
#
# from data to vulnerability
#  risk        -> vulnerability:vuln_severity
#  description -> vulnerability:desc_primary 
#  summary     -> vulnerability:desc_secondary
#  ref         -> reference:url (multiple reference records from ref element)
#
# from data to product
#  apptype -> product:name
#  version -> product:version
#
# from data to related
#  cve -> related:cve
#
# from data to solution
#  fix -> solution:desc
#
# from details to finding
#  ip         -> finding:ip
#  port       -> finding:port
#  vulnDetail -> finding:instance_data
#
# other 
#  sessionDate -> vulnerability:date_discovered
#  sessionDate -> finding:date
# 
# 17 Jan 2006
# ---------------------------------------------------------------------------


package appdetective_translation;

use basic_xml_parser;
use vuln_translator_utils;

use strict;

my $INITIALIZE_OBJECT_FIELDS = 0;

# ---------------------------------------------------------------------------
# Sync up return codes with translation utility module
# ---------------------------------------------------------------------------
my $OK    = $vuln_translator_utils::OK;
my $ERROR = $vuln_translator_utils::ERROR;


# ---------------------------------------------------------------------------
# Sync up message codes with translation utility module
# ---------------------------------------------------------------------------
my $SYS_MSG  = $vuln_translator_utils::SYS_MSG;
my $ERR_MSG  = $vuln_translator_utils::ERR_MSG;
my $WARN_MSG = $vuln_translator_utils::WARN_MSG;
my $INFO_MSG = $vuln_translator_utils::INFO_MSG;
my $DBG_MSG  = $vuln_translator_utils::DBG_MSG;


# ---------------------------------------------------------------------------
# Insist on the correct report
# ---------------------------------------------------------------------------
my $REPORT_INDICATOR = 'Vulnerability Details Report';


# ---------------------------------------------------------------------------
# Convert raw XML scan data into DB injection records.
#
# Input:
#  $input_xml_string
#   scalar: input XML data string
#
# Return:
#  $translated_appd_strings_ref
#   array ref: list of database injection records
#   undef if error
#
#  $status
#   scalar: processing status
#   $OK on success
# 
# ---------------------------------------------------------------------------
sub translate {
	
	# retrieve the parameter
	my ($input_xml_string) = @_;

#	print $input_xml_string."\n";
#	exit;

	my $translated_appd_strings_ref = [];
	my $msg_list_ref = [];

	my $call_status;
	my $this_sub = 'translate';

	#
	# evaluate the string
	#
	eval {

		#
		# Parse input stream into XML subelement list
		#
		my $xml_subelt_list_ref;
		($xml_subelt_list_ref, $call_status) = basic_xml_parser::parse($input_xml_string);

		# verify the results
		die "FATAL ERROR: Unable to parse input XML" if $call_status != $basic_xml_parser::SUCCESS;

#		foreach (@$xml_subelt_list_ref) { print "$_\n----------\n"; }
#		exit;

		#
		# Check for correct report input,
		#  exit immediately if not the correct report
		#
		my $report_type;
		($report_type, $call_status) = basic_xml_parser::get_first_named_child_data($xml_subelt_list_ref, 'reportTitle');

		# verify the results
		if ($call_status != $basic_xml_parser::SUCCESS) {

			push(@$msg_list_ref, ["$this_sub - unable to collect 'reportTitle' element from AppDetective scan status $call_status", $ERR_MSG]);

		}

#		print "REPORT TYPE: $report_type\n";
#		foreach (@$xml_subelt_list_ref) { print "$_\n----------\n"; } 
#		exit;

		# verify the results
		if ($report_type !~ m{$REPORT_INDICATOR}i) {
			
			my $fmt_str = clean_leading_and_trailing_space($report_type);
			die "FATAL ERROR: Need '$REPORT_INDICATOR' input file, found '$fmt_str'";

		}

		#
		# Get run date value
		#
		my $run_date;
#		($run_date, $call_status) = basic_xml_parser::get_first_named_child_data($xml_subelt_list_ref, 'sessionDate');
		($run_date, $call_status) = basic_xml_parser::get_first_named_child_data($xml_subelt_list_ref, 'testDate');

		if ($call_status != $basic_xml_parser::SUCCESS) {

			push(@$msg_list_ref, ["$this_sub - unable to collect 'sessionDate' element from AppDetective scan status $call_status", $WARN_MSG]);

		}

		$run_date = format_date_string($run_date);

#		print "DATE: $run_date\n";
#		foreach (@$xml_subelt_list_ref) { print "$_\n---------\n"; }
#		exit;

		# 
		# Extract the ip address and port from the appName element
		# 
		my $ip_data;
		my $port_data;

		# grab the appName data string
		my $data_string;
		($data_string, $call_status) = basic_xml_parser::get_first_named_child_data($xml_subelt_list_ref, 'appName');

		# parse the data string for ip and port
		if ($call_status == $basic_xml_parser::SUCCESS) {

			# match string for ip and port
			if ($data_string =~ /on ([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}).+port ([0-9]{1,5})/) {

				$ip_data   = $1;
				$port_data = $2;

			}

			# record error on a non-match
			else {

				push(@$msg_list_ref, ["$this_sub - unable to collect ip address and port from appName line"]);

			}

		}

		# parsing failed
		else {

			push(@$msg_list_ref, ["$this_sub - unable to collect 'appName' element from detail record $call_status", $WARN_MSG]);

		}


		# translate the results into standard form
		($translated_appd_strings_ref, $call_status) = translate_appdetective_results($xml_subelt_list_ref, $run_date, $ip_data, $port_data, $msg_list_ref);

#		foreach (@$translated_appd_strings_ref) { print $_."\n"; }
#		exit;

		# verify the results
		die "FATAL ERROR: Unable to translate result list" if $call_status != $OK;

	}; # eval
	
	# handle any errors
	if ($@) {

		push(@$msg_list_ref, ["FATAL PROCESSING ERROR: $@", $ERR_MSG]);
		#die;
		#$translation_status = $ERROR;

	}

	# return the translated results
	return ($translated_appd_strings_ref, $msg_list_ref);

} # translate()


# ---------------------------------------------------------------------------
# Return list of DB injection strings from parsed list of all XML scan
#  data.
# Each 'data' element is analyzed to generate a vulnerability object
#  and any associated finding, reference, solution, product objects.
# Injection strings are generated for each XML 'data' element.
# 
# Input:
#  $xml_subelt_list_ref
#   array ref: parsed XML data from basic_xml_parser::parse()
# 
#  $run_date
#   string: date of scan
# 
#  $msg_list_ref
#   array ref: list to store any processing error messages
# 
# Return:
#  $translated_appd_strings_ref
#   array ref: list of database injection records
#   undef if error
#
#  $status
#   scalar: processing status
#   $OK on success
# 
# ---------------------------------------------------------------------------
sub translate_appdetective_results {

	# grab the parameters
	my ($xml_subelt_list_ref, $run_date, $ip_data, $port_data, $msg_list_ref) = @_;

#	foreach (@$xml_subelt_list_ref) { print "$_\n----------\n"; }
#	exit;

	my $this_sub = 'translate_appdetective_results';

	my $call_status;
	my $TRANSLATOR_SOURCE_ID = 'appdetective_reader';

	my $translated_appd_strings_ref = [];

	#
	# Retrieve 'data' elements from output file
	#
	my $data_record_list_ref;
	($data_record_list_ref, $call_status) = basic_xml_parser::children_by_name($xml_subelt_list_ref, 'data');

#	foreach (@$data_record_list_ref) { foreach (@$_) { print "$_\n----------\n"; } }
#	exit;

	# verify the results
	if ($call_status != $basic_xml_parser::SUCCESS) {

		push(@$msg_list_ref, ["$this_sub - unable to retrieve 'data' elements from XML data", $WARN_MSG]);

	}
#	die "FATAL ERROR: Unable to retrieve 'data' elements from XML data" if $call_status != $basic_xml_parser::SUCCESS;


	#
	# For each 'data' element in the AppDetective output
	#

	my $record_count = 0;

	DATA_RECORD:

	foreach my $data_record_ref (@$data_record_list_ref) {

		$record_count++;


		#
		# DEBUG
		# 

#		print "\n\n==================== [$record_count] \@data_record_ref initially ====================\n\n";
#		foreach (@$data_record_ref) { print "$_\n----------\n"; }
#		print "\n\n==================================================\n\n";

		# 
		# END DEBUG
		# 


		#
		# Initialize db injection record objects
		#
		my $finding_list_ref   = [];
		my $related_list_ref   = [];
		my $sol_list_ref       = [];
		my $impact_list_ref    = [];
		my $swprod_list_ref    = [];
		my $reference_list_ref = [];

		#
		# Create (sparse) vulnerability db info object
		#
		my $vuln_obj_ref = {};
		($vuln_obj_ref, $call_status) = get_vulnerability($data_record_ref, $run_date, $msg_list_ref);


		# -------------------------------------------------------------------------
		#
		# DEBUG
		#

#		print "\n\n==================== [$record_count] \@data_record_ref after get_vulnerability ====================\n\n";
#		foreach (@$data_record_ref) { print "$_\n----------\n"; }
#		print "\n\n==================================================\n\n";

#		print "\n\n==================== [$record_count] \%vuln_obj_ref ====================\n\n";
#		foreach my $key (sort keys %$vuln_obj_ref) { print "[$key] ".$$vuln_obj_ref{$key}."\n----------\n"; }
#		print "\n\n==================================================\n\n";

		# 
		# END DEBUG
		#
		# ------------------------------------------------------------------------- 


		# verify the results
		if ($call_status != $OK) {

			push(@$msg_list_ref, ["$this_sub - error collecting vulnerability elements from AppDetective scan status $call_status", $WARN_MSG]);
			next DATA_RECORD;

		}


		#
		# Get related records
		#
		($related_list_ref, $call_status) = get_related($data_record_ref, $msg_list_ref);


		# 
		# DEBUG
		#

#		print "\n\n==================== [$record_count] \@data_record_ref after get_related ====================\n\n";
#		foreach (@$data_record_ref) { print "$_\n----------\n"; }
#		print "\n\n==================================================\n\n";

#		print "\n\n==================== [$record_count] \%related_list_ref ====================\n\n";
#		foreach my $key (sort keys %$related_list_ref) { print "[$key]".$$related_list_ref{$key}."\n----------\n"; }
#		print "\n\n==================================================\n\n";

		# 
		# END DEBUG
		# 


		# verify the results
		if ($call_status != $OK) {

			push(@$msg_list_ref, ["$this_sub - error collecting related elements from AppDetective scan status $call_status", $WARN_MSG]);

		}

  
		#
		# Get any references specified in data object
		#
		($reference_list_ref, $call_status) = get_references($data_record_ref, $msg_list_ref);


		# 
		# DEBUG
		# 

#		print "\n\n========== [$record_count] \@data_record_ref after get_references ====================\n\n";
#		foreach (@$data_record_ref) { print "$_\n---------\n"; }
#		print "\n\n==================================================\n\n";

#		print "\n\n==================== [$record_count] \%reference_list_ref ====================\n\n";
#		foreach my $key (sort keys %$reference_list_ref) { print "[$key]".$$reference_list_ref{$key}."\n----------\n";  }
#		print "\n\n==================================================\n\n";
		
		# 
		# END DEBUG
		# 

		# verify the results
		if ($call_status != $OK) {

			push(@$msg_list_ref, ["$this_sub - error collecting reference elements from AppDetective scan status $call_status", $WARN_MSG]);

		}
    
    
		#
		# Get any solution data
		#
		($sol_list_ref, $call_status) = get_solutions($data_record_ref, $msg_list_ref);

		# 
		# DEBUG
		# 

#		print "\n\n==================== [$record_count] \@data record_ref after get_references ====================\n\n";
#		foreach (@$data_record_ref) { print "$_\n---------\n"; }
#		print "\n\n==================================================\n\n";

#		print "\n\n==================== [$record_count] \%sol_list_ref ====================\n\n";
#		foreach my $key (sort keys %$sol_list_ref) { print "[$key]".$$sol_list_ref{$key}."\n---------\n"; }
#		print "\n\n==================================================\n\n";

		# 
		# END DEBUG
		# 


		# verify the results
		if ($call_status != $OK) {

			push(@$msg_list_ref, ["$this_sub - error collecting fix/solution elements from AppDetective scan status $call_status", $WARN_MSG]);
		}


		#
		# Get product data
		#
		($swprod_list_ref, $call_status) = get_products($data_record_ref, $msg_list_ref);

		# 
		# DEBUG
		# 

#		print "\n\n==================== [$record_count] \@data_record_ref after get_products ====================\n\n";
#		foreach (@$data_record_ref) { print "$_\n---------\n"; }
#		print "\n\n==================================================\n\n";

#		print "\n\n==================== [$record_count] \%swprod_list_ref  ====================\n\n";
#		foreach my $key (sort keys %$swprod_list_ref) { print "[$key]".$$swprod_list_ref{$key}."\n----------\n"; }
#		print "\n\n==================================================\n\n";

		# 
		# END DEBUG
		# 


		# verify the results
		if ($call_status != $OK) {

			push(@$msg_list_ref, ["$this_sub - error collecting product elements from AppDetective scan status $call_status", $WARN_MSG]);

		}

    
		#
		# Get findings
		#
		($finding_list_ref, $call_status) = get_findings($data_record_ref, $run_date, $ip_data, $port_data, $msg_list_ref);

		# 
		# DEBUG
		# 

#		print "\n\n==================== [$record_count] \@data_record_ref after get_findings ====================\n\n";
#		foreach (@$data_record_ref) { print "$_\n----------\n"; }
#		print "\n\n==================================================\n\n";

#		print "\n\n==================== [$record_count] \%finding_list_ref ====================\n\n";
#		foreach (@$finding_list_ref) { foreach (@$_)  { print "$_\n---------\n"; } }
#		print "\n\n==================================================\n\n";

		# 
		# END DEBUG
		# 


		# verify the results
		if ($call_status != $OK) {

			push(@$msg_list_ref, ["$this_sub - error collecting finding elements from AppDetective scan status $call_status", $WARN_MSG]);

		}

    
		#
		# Translate vulnerability objects into DB injection records
		#
		my $entry_record_list = vuln_translator_utils::format_translated_entry_list($vuln_obj_ref,
                		                                                            $finding_list_ref,
                                		                                            $related_list_ref,
                                                		                            $sol_list_ref,
                                                                		            $impact_list_ref,
											$swprod_list_ref,
		                                                                            $reference_list_ref,
	               		                                                            $msg_list_ref);





#		foreach (@$entry_record_list) { print "$_\n----------\n"; }
#		print "burp\n\n";
#		exit;

		push(@$translated_appd_strings_ref, @$entry_record_list);

#		test
#		print "PLUGIN $plugin_id\n";
#		foreach my $cve_key (keys %related_cves) { print " $cve_key\n"; }
#		endtest

	} # foreach data_record

#	exit;

	# return the translated results
	return ($translated_appd_strings_ref, $OK);

} # translate_appdetective_results


# ---------------------------------------------------------------------------
# Analyze 'data' element to retrieve vulnerability record fields.
# 
# Input:
#  $data_record_ref
#   array ref: entire 'data' element in parsed XML format
# 
#  $run_date
#   string: date of scan
# 
#  $msg_list_ref
#   array ref: list to store any processing error messages
# 
# Return:
#  $vuln_obj_ref
#   hash ref: vulnerability object fields
#
#  $status
#   scalar: processing status
#   $OK on success
# 
# ---------------------------------------------------------------------------
sub get_vulnerability {

	# grab the paramters
	my ($data_record_ref, $run_date, $msg_list_ref) = @_;

#	foreach (@$data_record_ref) { print "$_\n----------\n"; }
#	exit;
	
	# identify the subroutine
	my $this_sub = 'get_vulnerability';

	# 
	my $call_status;  
	my $vuln_obj_ref = {}; # hash reference

	# 
	# initialize the object fields
	# 
	if ($INITIALIZE_OBJECT_FIELDS) { vuln_translator_utils::initialize_vulnerability_object_fields($vuln_obj_ref); }
	else { vuln_translator_utils::record_absent_vulnerability_elt($vuln_obj_ref); }

	# grab the date discovered
	$vuln_obj_ref->{$vuln_translator_utils::VULN_DT_DISCV} = $run_date;

	#
	# 'data' elements can be empty in the XML
	# Only use this to check for existence of actual data in the element.
	#  - if no CVE found, return here. Empty 'data' XML element will be ignored.
	#
	my $cve_val;
	($cve_val, $call_status) = basic_xml_parser::get_first_named_child_data($data_record_ref, 'cve');

	# verify the results
	if ($call_status != $basic_xml_parser::SUCCESS) {

		push(@$msg_list_ref, ["$this_sub - unable to collect 'cve' element from AppDetective scan status $call_status", $WARN_MSG]);
		return ($vuln_obj_ref, $ERROR);

	}

	# 
	# RISK
	# 
	my $risk_val;
	($risk_val, $call_status) = basic_xml_parser::get_first_named_child_data($data_record_ref, 'risk');

	# verify the results
	if ($call_status != $basic_xml_parser::SUCCESS) {

		push(@$msg_list_ref, ["$this_sub - unable to collect 'risk' element from AppDetective scan status $call_status", $WARN_MSG]);

	}

	$vuln_obj_ref->{$vuln_translator_utils::VULN_VULN_SEV} = translate_severity($risk_val);

	#
	# Map description to primary description, summary to secondary description
	#
	my $string_block;
	($string_block, $call_status) = basic_xml_parser::get_first_named_child_data($data_record_ref, 'description');

	# verify the results
	if ($call_status != $basic_xml_parser::SUCCESS) {

		push(@$msg_list_ref, ["$this_sub - unable to collect 'description' element from AppDetective scan status $call_status", $WARN_MSG]);

	}

#	print "$string_block\n";

	# strip the newlines form the description
	$vuln_obj_ref->{$vuln_translator_utils::VULN_DESC_PRIMARY} = remove_newlines($string_block);

	# 
	# SUMMARY
	# 
	($string_block, $call_status) = basic_xml_parser::get_first_named_child_data($data_record_ref, 'summary');

	# verity the results
	if ($call_status != $basic_xml_parser::SUCCESS) {

		push(@$msg_list_ref, ["$this_sub - unable to collect 'summary' element from AppDetective scan status $call_status", $WARN_MSG]);

	}

	# strip the newlines from the secondary description
	$vuln_obj_ref->{$vuln_translator_utils::VULN_DESC_SECONDARY} = remove_newlines($string_block);


#	foreach my $key (sort keys %$vuln_obj_ref) { print "[$key] ",$$vuln_obj_ref{$key}."\n"; }
#	print "---------\n";

	# return the results
	return($vuln_obj_ref, $OK);

} # get_vulnerability()


# ---------------------------------------------------------------------------
# Retrieve any references from XML 'data' element.
# Parses the 'ref' child of the 'data' element, chops out http: reference
#  strings, creates one reference record for each string.
# 
# Input:
#  $data_record_ref
#   array ref: entire 'data' element in parsed XML format
# 
#  $msg_list_ref
#   array ref: list to store any processing error messages
# 
# Return:
#  $ref_list
#   array ref: list of reference hash objects
# 
#  $status
#   scalar: processing status
#   $OK on success
#
# ---------------------------------------------------------------------------
sub get_references {

	my ($data_record_ref, $msg_list_ref) = @_;

#	foreach (@$data_record_ref) { print "$_\n----------\n"; }

	my $this_sub = 'get_references';
	my $call_status;
  
	my $ref_list = [];
  
	#
	# Get reference data block
	#
	my $reference_data;
	($reference_data, $call_status) = basic_xml_parser::get_first_named_child_data($data_record_ref, 'ref');

	if ($call_status != $basic_xml_parser::SUCCESS) {

		    push(@$msg_list_ref, ["$this_sub - unable to collect 'ref' element from AppDetective scan status $call_status", $WARN_MSG]);

	}
  
	#
	# Get list of reference elements from data block
	# Replace newlines with spaces, 
	#  match everything from http:// to trailing whitespace
	#
	$reference_data =~ s{\n}{ }g;
	my @urls = ($reference_data =~ m{(http://[^\s]*)}ig);

	#
	# For each reference element
	#
	foreach my $ref_url(@urls) {

#		int "$ref_url\n";
  
		#
		# Create reference object, add it to reference list
		#
		my $ref_obj = {};
		$ref_obj->{$vuln_translator_utils::REF_URL} = $ref_url;
    
		push(@$ref_list, $ref_obj);

	} # foreach
 
	# return the results 
	return ($ref_list, $OK);

} # get references()


# ---------------------------------------------------------------------------
# Maps 'fix' data from the scan results to injection solution record(s).
#
#
# Input:
#  $data_record_ref
#   array ref: entire 'data' element in parsed XML format
# 
#  $msg_list_ref
#   array ref: list to store any processing error messages
# 
# Return:
#  $sol_list
#   array ref: list of solution hash objects
# 
#  $status
#   scalar: processing status
#   $OK on success
#
# ---------------------------------------------------------------------------
sub get_solutions {
	
	my ($data_record_ref, $msg_list_ref) = @_;

	my $this_sub = 'get_solutions';
	my $call_status;
  
	my $sol_list = [];
  
	#
	# Get fix data block
	#
	my $fix_data;
	($fix_data, $call_status) = basic_xml_parser::get_first_named_child_data($data_record_ref, 'fix');

	if ($call_status != $basic_xml_parser::SUCCESS) {

		push(@$msg_list_ref, ["$this_sub - unable to collect 'fix' element from AppDetective scan status $call_status", $WARN_MSG]);

	}

	$fix_data = clean_leading_and_trailing_space($fix_data);
  
	#
	# Create solution object if fix data exists,
	#  add it to solution list
	#
	if (length($fix_data) > 0) {

		my $solution_obj = {};
		$solution_obj->{$vuln_translator_utils::SOL_DESC} = $fix_data;
		push(@$sol_list, $solution_obj);

	}
  
	return ($sol_list, $OK);

} # get_solutions()


# ---------------------------------------------------------------------------
# Maps 'cve' data from the scan results to related record(s).
#
#
# Input:
#  $data_record_ref
#   array ref: entire 'data' element in parsed XML format
# 
#  $msg_list_ref
#   array ref: list to store any processing error messages
# 
# Return:
#  $related_list
#   array ref: list of 'related' hash objects
# 
#  $status
#   scalar: processing status
#   $OK on success
#
# ---------------------------------------------------------------------------
sub get_related {

	# grab the parameters
	my ($data_record_ref, $msg_list_ref) = @_;

#	foreach (@$data_record_ref) { print "$_\n---------\n"; }

	my $this_sub = 'get_related';
	my $related_list = [];
    
	# execute the call
	my ($related_cve, $call_status) = basic_xml_parser::get_first_named_child_data($data_record_ref, 'cve');

#	print "$related_cve\n----------\n";

	# error check the call
	if ($call_status != $basic_xml_parser::SUCCESS) {

		push(@$msg_list_ref, ["$this_sub - unable to collect 'cve' element from AppDetective scan status $call_status", $WARN_MSG]);
		return ($related_list, $ERROR);

	}
  
	# error check the discovered CVE
	if ($related_cve =~ /^(?:CVE|CAN)-[0-9]{4,4}-[0-9]{4,4}$/) {

		my $rel_obj_ref = {};
		$rel_obj_ref->{$vuln_translator_utils::REL_CVE} = $related_cve;
		push(@$related_list, $rel_obj_ref);

	}

	# return the results
	return ($related_list, $OK);

} # get_related()


# ---------------------------------------------------------------------------
# Retrieves product information from the XML 'data' element.
# Accesses 'apptype' and 'version' fields to generate product info.
# 
# Input:
#  $data_record_ref
#   array ref: entire 'data' element in parsed XML format
# 
#  $msg_list_ref
#   array ref: list to store any processing error messages
# 
# Return:
#  $prod_list
#   array ref: list of product hash objects
# 
#  $status
#   scalar: processing status
#   $OK on success
# 
# ---------------------------------------------------------------------------
sub get_products {

	my ($data_record_ref, $msg_list_ref) = @_;

	my $this_sub = 'get_products';
	my $call_status;
  
	my $prod_list = [];
  
	#
	# Get apptype and version data
	#
	my $app_data;
	($app_data, $call_status) = basic_xml_parser::get_first_named_child_data($data_record_ref, 'apptype');
	if ($call_status != $basic_xml_parser::SUCCESS) {
		push(@$msg_list_ref, ["$this_sub - unable to collect 'apptype' element from AppDetective scan status $call_status", $WARN_MSG]);
		return ($prod_list, $ERROR);
    }
	$app_data = clean_leading_and_trailing_space($app_data);
	
	my $version_data;
	($version_data, $call_status) = basic_xml_parser::get_first_named_child_data($data_record_ref, 'version');
	if ($call_status != $basic_xml_parser::SUCCESS) {
		push(@$msg_list_ref, ["$this_sub - unable to collect 'version' element from AppDetective scan status $call_status", $WARN_MSG]);
		return ($prod_list, $ERROR);
    }
	$version_data = clean_leading_and_trailing_space($version_data);
	
	
	my ($app_vendor, $app_name) = vendor_and_name($app_data, $msg_list_ref);
	
	#
	# Create product object,
	#  add it to product list
	#
	my $prod_obj = {};
	$prod_obj->{$vuln_translator_utils::SWPROD_VENDOR}  = $app_vendor;
	$prod_obj->{$vuln_translator_utils::SWPROD_NAME}    = $app_name;
	$prod_obj->{$vuln_translator_utils::SWPROD_VERSION} = $version_data;
	$prod_obj->{$vuln_translator_utils::SWPROD_META}    = "$app_vendor $app_name $version_data";
	push(@$prod_list, $prod_obj);
	
	return ($prod_list, $OK);

} # get_products


# ---------------------------------------------------------------------------
# Analyzed 'details' children of 'data' object to generate finding injection
#  records.
# Collects ip, port, vulnDetail element data, uses report run date for 
#  finding date.
#
# Input:
#  $data_record_ref
#   array ref: entire 'data' element in parsed XML format
# 
#  $msg_list_ref
#   array ref: list to store any processing error messages
# 
# Return:
#  $finding_list
#   array ref: list of finding hash objects
# 
#  $status
#   scalar: processing status
#   $OK on success
#
# ---------------------------------------------------------------------------
sub get_findings {

	my ($data_record_ref, $run_date, $ip_data, $port_data, $msg_list_ref) = @_;

	my $this_sub = 'get_findings';
	my $call_status;
  
	my $finding_list = [];
 
	# 
	# DEBUG
	# 

#	foreach (@$data_record_ref) { print "$_\n----------\n"; }
#	exit;

	# 
	# END DEBUG
	# 


 
	#
	# Get list of detail elements
	#
	my $detail_record_list_ref;

	($detail_record_list_ref, $call_status) = basic_xml_parser::children_by_name($data_record_ref, 'details');

	if ($call_status != $basic_xml_parser::SUCCESS) {

		push(@$msg_list_ref, ["$this_sub - unable to retrieve 'details' elements from XML data", $WARN_MSG]);
		return ($finding_list, $ERROR);
	}
 
	#
	# For each detail element found
	#
	DETAIL_RECORD:

	foreach my $detail_record_ref (@$detail_record_list_ref) {

#		print '1';

		#
		# Get vulnerability detail
		# 

#		($ip_data, $call_status) = basic_xml_parser::get_first_named_child_data($detail_record_ref, 'ip');
#	
#		if ($call_status != $basic_xml_parser::SUCCESS) {
#
#			push(@$msg_list_ref, ["$this_sub - unable to collect 'ip' element from detail record $call_status", $WARN_MSG]);
#			next DETAIL_RECORD;
#
#		}
#
#		$ip_data = clean_leading_and_trailing_space($ip_data);
#   
#		my $port_data;
#
#		($port_data, $call_status) = basic_xml_parser::get_first_named_child_data($detail_record_ref, 'port');
#
#		if ($call_status != $basic_xml_parser::SUCCESS) {
#
#			push(@$msg_list_ref, ["$this_sub - unable to collect 'port' element from detail record $call_status", $WARN_MSG]);
#			next DETAIL_RECORD;
#
#		}
#
#		$port_data = clean_leading_and_trailing_space($port_data);

		my $vdetail_data;

		($vdetail_data, $call_status) = basic_xml_parser::get_first_named_child_data($detail_record_ref, 'vulnDetail');

		if ($call_status != $basic_xml_parser::SUCCESS) {

			push(@$msg_list_ref, ["$this_sub - unable to collect 'vulnDetail' element from detail record $call_status", $WARN_MSG]);
			next DETAIL_RECORD;

		}

		$vdetail_data = clean_leading_and_trailing_space($vdetail_data);
    
		#
		# Create finding object,
		#  add it to findings list
		#
		#my $SCAN_TOOL = 'appdetective_reader';
    
		my $finding_obj = {};
		$finding_obj->{$vuln_translator_utils::FIND_IP} = $ip_data;
		$finding_obj->{$vuln_translator_utils::FIND_PORT} = $port_data;
		$finding_obj->{$vuln_translator_utils::FIND_INST_DATA} = $vdetail_data;
		$finding_obj->{$vuln_translator_utils::FIND_DATE} = $run_date;
		#$finding_obj->{$vuln_translator_utils::FIND_SCANTOOL} = $SCAN_TOOL;
    
		push(@$finding_list, $finding_obj);

	}
  
	return ($finding_list, $OK);

} # get_findings


sub get_vuln_detail {



} # get_vuln_detail()


# test util
sub print_hash_ref {

	my ($hash_ref) = @_;

	foreach my $key (sort keys %$hash_ref) {

		print "$key:$hash_ref->{$key}\n";

    }

} # print_hash_ref()


# ---------------------------------------------------------------------------
# Pull leading indentation out of multiline data.
# ---------------------------------------------------------------------------
sub format_info_data {
	
	my ($info_data) = @_;

	$info_data =~ s{^\s+}{}gmx;
	
	return($info_data);

} # format_info_data()


# ---------------------------------------------------------------------------
# Pull a list of CVE-nnnn-nnnn or CAN-nnnn-nnnn strings from
# multiline input.
# ---------------------------------------------------------------------------
sub extract_CVE_list {

	my ($raw_data_str) = @_;
	my @cve_list = ($raw_data_str =~ m{(CAN-\d\d\d\d-\d\d\d\d|CVE-\d\d\d\d-\d\d\d\d)}gi);

	return(\@cve_list);

} # extract_CVE_list()

# ---------------------------------------------------------------------------
# Replace \n with space in multiline data.
# ---------------------------------------------------------------------------
sub remove_newlines {

	my ($input_str) = @_;
	my $output_str = $input_str;

	#
	# Take those newlines out (replace with space character)
	#  consider replacing these with a tag that can later be used to format
	#  line breaks back in.
	#
	$output_str =~ s{\n}{ }g;
	
	return ($output_str);

} # remove_newlines()


# ---------------------------------------------------------------------------
# Remove whitespace padding from an input string.
# ---------------------------------------------------------------------------
sub clean_leading_and_trailing_space {

	my ($input_str) = @_;
	
	my $output_str = $input_str;
	
	$output_str =~ s{^\s+}{};
	$output_str =~ s{\s+$}{};

	return ($output_str);

} # clean_leading_and_trailing_space()


# ---------------------------------------------------------------------------
# Convert '11/15/2005 9:20:46 PM' to '2005-11-15'
# ---------------------------------------------------------------------------
sub format_date_string {

	my ($input_str) = @_;

	#
	# Strip any leading whitespace
	#
	$input_str =~ s{\s+}{};

	# match the date
#	my $short_date = substr($input_str, 0, 10);
#	my @dt_fields = split(/\//, $short_date);
#	die("format_date_string - unrecognized mm/dd/yyyy date format '$short_date'") if (scalar(@dt_fields) != 3);
#	my $output_str = "$dt_fields[2]-$dt_fields[0]-$dt_fields[1]";

	# string to return adjusted date format
	my $output_str = "";

	# regexp match the date
	if ( $input_str =~ /([0-9]{1,2})\/([0-9]{1,2})\/([0-9]{1,4})/ ) {

		$output_str = "$3-$1-$2";

	}

	else { die("format_date_string - unrecognized mm/dd/yyyy date format in '$input_str'"); }

	return($output_str);

} # format_date_string()

# ---------------------------------------------------------------------------
# Get vendor and product from apptype element data.
# Lookup generated from list at:
#  http://www.appsecurity.com/products/appdetective
#
# Input:
#  $apptype
#   string: data string from apptype XML element
#
# Return:
#  $vendor
#   string: vendor name or $apptype if lookup not found
#
#  $product_name
#   string: product or $apptype if lookup not found
# ---------------------------------------------------------------------------

my $VENDOR_IDX   = 0;
my $PRODNAME_IDX = 1;
my %names_for = {
  'MySQL'                     => ['MySQL AB', 'MySQL'],
  'Oracle'                    => ['Oracle', 'Oracle'],
  'Sybase'                    => ['Sybase', 'Sybase'],
  'IBM DB2'                   => ['IBM', 'DB2'],
  'IBM DB2 on Mainframe'      => ['IBM', 'DB2 on Mainframe'],
  'Microsoft SQL Server'      => ['Microsoft', 'SQL Server'],
  'Oracle Application Server' => ['Oracle', 'Application Server'],
  'Notes'                     => ['Lotus', 'Notes'],
  'Domino'                    => ['Lotus', 'Domino'],
  };
  
sub vendor_and_name {

	my ($apptype, $msg_list_ref) = @_;

	my $vendor = $apptype;
	my $product_name = $apptype;

	my $found_it = 0;

  NAME_KEY:
	foreach my $name_key (keys %names_for) {

		if ($apptype =~ m{$name_key}i) {
			my $names = $names_for{$name_key};
			$vendor       = $names->[$VENDOR_IDX];
			$product_name = $names->[$PRODNAME_IDX];
			$found_it = 1;
			last NAME_KEY;
		}
    }
    
	if (!$found_it) {

		push(@$msg_list_ref, ["vendor_and_name - unrecognized application '$apptype'", $WARN_MSG]);

	}
    
	return ($vendor, $product_name);

} # vendor_and_name()


#
# Map severity string to level between 0 and 100.
# Defaults to 50 if no level specified in record.
#
my %severity_for = (
  'High'          => $vuln_translator_utils::HIGH_SEVERITY,
  'Medium'        => $vuln_translator_utils::MEDIUM_SEVERITY,
  'Low'           => $vuln_translator_utils::LOW_SEVERITY,
  'Informational' => $vuln_translator_utils::NO_SEVERITY,
  );

sub translate_severity {

	my ($severity_str, $msg_list_ref) = @_;
	my $severity_val;
  
	$severity_str =clean_leading_and_trailing_space($severity_str);
  
	#
	# If severity is coming in as a number from 1 to 10
	#
	if ($severity_str =~ m{\d+(\.\d*)?}) {
		#
		# Get it into 0 to 100 scale
		#
		$severity_val = $severity_str * 10;
    }
	else {
		#
		# Otherwise map qualitative string to a number
		#
		if (defined($severity_for{$severity_str})) {

			$severity_val = $severity_for{$severity_str};

		}
		else {

			$severity_val = $vuln_translator_utils::DEFAULT_SEVERITY;
			push(@$msg_list_ref, ["translate_severity - unable to map severity for '$severity_str', setting severity to $severity_val", $WARN_MSG]);

		} # else

    } # else
	
	return ($severity_val);

} # translate_severity()
