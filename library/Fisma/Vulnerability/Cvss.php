<?php
/**
 * Copyright (c) 2010 Endeavor Systems, Inc.

 * This file is part of OpenFISMA.
 *
 * OpenFISMA is free software: you can redistribute it and/or modify it under the terms of the GNU General Public
 * License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * OpenFISMA is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with OpenFISMA.  If not, see
 * {@link http://www.gnu.org/licenses/}.
 */

/**
 * A CVSS (Common Vulnerability Scoring System) Calculator and Vector Generator
 * http://www.first.org/cvss/cvss-guide.html
 *
 * Can calculate a CVSS score or generate a CVSS vector.
 *
 * @author     Christian Smith
 * @copyright  (c) Endeavor Systems, Inc. 2010 {@link http://www.endeavorsystems.com}
 * @license    http://www.openfisma.org/content/license GPLv3
 * @package    Fisma
 * @subpackage Fisma_Vulnerability
 */

class Fisma_Vulnerability_Cvss
{
    /**
     * Base Access Vector (AV) set value
     *
     * @var float
     */
    protected $_baseAccessVector;

    /**
     * Base Access Complexity (AC) set value
     *
     * @var float
     */
    protected $_baseAccessComplexity;

    /**
     * Base AuthenticationValues (AU) set value
     *
     * @var float
     */
    protected $_baseAuthValues;

    /**
     * Base/Impact Confidentiality Impact (C) set value
     *
     * @var float
     */
    protected $_baseConfImpact;

    /**
     * Base/Impact Integrity Impact (I) set value
     *
     * @var float
     */
    protected $_baseIntegImpact;

    /**
     * Base/Impact Availability Impact (A) set value
     *
     * @var float
     */
    protected $_baseAvailImpact;

    /**
     * Temporal Exploitability (E) set value
     *
     * @var float
     */
    protected $_temporalExploitability;

    /**
     * Temporal Remediation Level (RL) set value
     *
     * @var float
     */
    protected $_temporalRemediationLevel;

    /**
     * Temporal Report Confidence (RC) set value
     *
     * @var float
     */
    protected $_temporalReportConfidence;

    /**
     * Environmental Collateral Damage (CDP) set value
     *
     * @var float
     */
    protected $_envCollateralDamage;

    /**
     * Environmental Target Distribution (TD) set value
     *
     * @var float
     */
    protected $_envTargetDist;

    /**
     * Environmental Configuration Requirement (CR) set value
     *
     * @var float
     */
    protected $_envConfReq;

    /**
     * Environmental Integrity Requirement (IR) set value
     *
     * @var float
     */
    protected $_envIntegReq;

    /**
     * Environmental Availability Requirement (AR) set value
     *
     * @var float
     */
    protected $_envAvailReq;

    /**
     * Stored Result of calculating the Base score incorporating Exploitability and Impact:
     * BaseScore = round_to_1_decimal(((0.6*Impact)+(0.4*Exploitability)-1.5)*f(Impact))
     *
     * @var float
     */
    protected $_baseScoreResult;

    /**
     * Stored result of calculating the Base Impact score using:
     * Impact = 10.41*(1-(1-ConfImpact)*(1-IntegImpact)*(1-AvailImpact))
     *
     * @var float
     */
    protected $_impactScoreResult;

    /**
     * Stored result of calculating the Base Exploitability score using:
     * Exploitability = 20*AccessVector*AccessComplexity*Authentication
     *
     * @var float
     */
    protected $_exploitabilityScoreResult;

    /**
     * Stored result of calculating the Temporal score
     * TemporalScore = round_to_1_decimal(BaseScore*Exploitability*RemediationLevel*ReportConfidence)
     *
     * @var mixed
     */
    protected $_temporalScoreResult;

    /**
     * Stored result of calculating the Environmental using AdjustedTemporal and CollateralDamagePotential
     * EnvironmentalScore = round_to_1_decimal((AdjustedTemporal+
     * (10-AdjustedTemporal)*CollateralDamagePotential)*TargetDistribution)
     *
     * @var mixed
     */
    protected $_environmentalScoreResult;

    /**
     * Adjusted base score result
     * BaseScore = round_to_1_decimal(((0.6*Impact)+(0.4*Exploitability)-1.5)*f(Impact))
     *
     * @var float
     */
    protected $_adjustedBaseScoreResult;

    /**
     * Adjusted impact score result
     * AdjustedImpact = min(10,10.41*(1-(1-ConfImpact*ConfReq)*(1-IntegImpact*IntegReq)
     * *(1-AvailImpact*AvailReq)))
     *
     * @var double
     */
    protected $_adjustedImpactScoreResult;

    /**
     * AdjustedTemporal = TemporalScore recomputed with the BaseScores Impact sub-equation
     *                    replaced with the AdjustedImpact equation
     *
     * @var double
     */
    protected $_adjustedTemporalScoreResult;

    /**
     * Setup a Base Vector structure.
     *
     * @var array
     */
    protected $_baseVector = array(
                       'AV' => null,
                       'AC' => null,
                       'Au' => null,
                        'C' => null,
                        'I' => null,
                        'A' => null,
        );

    /**
     * Setup a Base Vector Label structure.
     *
     * @var array
     */
    protected $_baseVectorLabels = array(
                       'AV' => null,
                       'AC' => null,
                       'Au' => null,
                        'C' => null,
                        'I' => null,
                        'A' => null,
        );

    /**
     * Setup a Temporal Vector structure.
     *
     * @var array
     */
    protected $_temporalVector = array(
                        'E' => 'ND',
                       'RL' => 'ND',
                       'RC' => 'ND',
         );

    /**
     * Setup a Environmental Vector structure.
     *
     * @var array
     */
    protected $_environmentalVector = array(
                      'CDP' => 'ND',
                       'CD' => 'ND',
                       'TD' => 'ND',
                       'CR' => 'ND',
                       'IR' => 'ND',
                       'AR' => 'ND',
         );

    /**
     * Defined Access Vector (AV) values
     *
     * @var array
     */
    public static $accessVectorValues = array(
                    'local' => 0.395,
         'adjacent_network' => 0.646,
                  'network' => 1.0,
         );

    /**
     * Defined Access Complexity (AC) values
     *
     * @var array
     */
    public static $accessComplexityValues = array(
                     'high' => 0.35,
                   'medium' => 0.61,
                      'low' => 0.71,
         );

    /**
     * Defined Authentication Values (AU) values
     *
     * @var array
     */
    public static $authenticationValues = array (
        'multiple_instance' => 0.45,
          'single_instance' => 0.56,
                     'none' => 0.704,
        );

    /**
     * Defined Confidentiality Impact (C) scoring values
     *
     * @var array
     */
    public static $confidentialityImpactValues = array(
                     'none' => 0.0,
                  'partial' => 0.275,
                 'complete' => 0.660,
        );

    /**
     * Defined Integrity Impact (I) scoring values
     *
     * @var array
     */
    public static $integrityImpactValues = array(
                     'none' => 0.0,
                  'partial' => 0.275,
                 'complete' => 0.660,
        );

    /**
     * Defined Availability Impact (A) scoring values
     *
     * @var array
     */
    public static $availabilityImpactValues = array(
                     'none' => 0.0,
                  'partial' => 0.275,
                 'complete' => 0.660,
        );

    /**
     * Defined Exploitability Values (E) scoring values
     *
     * @var array
     */
    public static $exploitabilityValues = array(
                 'unproven' => 0.85,
         'proof_of_concept' => 0.9,
               'functional' => 0.95,
                     'high' => 1.0,
              'not_defined' => 1.0,
        );

    /**
     * Defined Remediation Level (RL) scoring values
     *
     * @var array
     */
    public static $remediationLevelValues = array(
             'official_fix' => 0.87,
            'temporary_fix' => 0.90,
               'workaround' => 0.95,
              'unavailable' => 1.00,
              'not_defined' => 1.00,
        );

    /**
     * Defined Report Confidence (RC) scoring values
     *
     * @var array
     */
    public static $reportConfidenceValues = array(
              'unconfirmed' => 0.90,
           'uncorroborated' => 0.95,
                'confirmed' => 1.00,
              'not_defined' => 1.00,
        );

    /**
     * Defined Collateral Damage (CD) scoring values
     *
     * @var array
     */
    public static $collateralDamageValues = array(
                     'none' => 0,
                      'low' => 0.1,
               'low_medium' => 0.3,
              'medium_high' => 0.4,
                     'high' => 0.5,
              'not_defined' => 0,
        );

    /**
     * Defined Target Distribution (TD) scoring values
     *
     * @var array
     */
    public static $targetDistributionValues = array(
                     'none' => 0,
                      'low' => 0.25,
                   'medium' => 0.75,
                     'high' => 1.00,
              'not_defined' => 1.00,
        );

    /**
     * Defined Confidentiality Requirement (CR) scoring value
     *
     * @var array
     */
    public static $confidentialityRequirementValues = array(
                      'low' => 0.5,
                   'medium' => 1.0,
                     'high' => 1.51,
              'not_defined' => 1.0,
        );

    /**
     * Defined Integrity Requirement (IR) scoring values
     *
     * @var array
     */
    public static $integrityRequirementValues = array(
                      'low' => 0.5,
                   'medium' => 1.0,
                     'high' => 1.51,
              'not_defined' => 1.0,
        );

    /**
     * Defined Availability Requirement (AR) scoring values
     *
     * @var array
     */
    public static $availabilityRequirementValues = array(
                      'low' => 0.5,
                   'medium' => 1.0,
                     'high' => 1.51,
              'not_defined' => 1.0,
        );

    /**
     * Sets the Access Vector (AV) value and vector
     *
     * @param string $av Access Vector [L,A,N]
     */
    public function setAV($av = 'ND')
    {
        switch ($av) {
            case 'L':
                $this->_baseVector['AV'] = 'L';
                $this->_baseVectorLabels['AV'] = 'Local';
                $this->_baseAccessVector = self::$accessVectorValues['local'];
                break;
            case 'A':
                $this->_baseVector['AV'] = 'A';
                $this->_baseVectorLabels['AV'] = 'Adjacent Network';
                $this->_baseAccessVector = self::$accessVectorValues['adjacent_network'];
                break;
            case 'N':
                $this->_baseVector['AV'] = 'N';
                $this->_baseVectorLabels['AV'] = 'Network';
                $this->_baseAccessVector = self::$accessVectorValues['network'];
                break;
            default:
                throw Fisma_Zend_Exception('Failed to set Access Vector');
                break;
        }
    }

    /**
     * Gets the Access Vector (AV) value
     *
     * @return float
     */
    public function getAV()
    {
        return $this->_baseAccessVector;
    }

    /**
     * Sets the Access Complexity (AC) value and vector
     *
     * @param string $ac Access Complexity [H,M,L]
     */
    public function setAC($ac)
    {
        switch ($ac) {
            case 'H':
                $this->_baseVector['AC'] = 'H';
                $this->_baseVectorLabels['AC'] = 'High';
                $this->_baseAccessComplexity = self::$accessComplexityValues['high'];
                break;
            case 'M':
                $this->_baseVector['AC'] = 'M';
                $this->_baseVectorLabels['AC'] = 'Medium';
                $this->_baseAccessComplexity = self::$accessComplexityValues['medium'];
                break;
            case 'L':
                $this->_baseVector['AC'] = 'L';
                $this->_baseVectorLabels['AC'] = 'Low';
                $this->_baseAccessComplexity = self::$accessComplexityValues['low'];
                break;
            default:
                throw new Fisma_Zend_Exception('Failed to set Access Complexity');
                break;
        }
    }

    /**
     * Gets the Access Complexity (AC) value
     *
     * @return string
     */
    public function getAC()
    {
        return $this->_baseAccessComplexity;
    }

    /**
     * Sets the Authentication Values (Au) value and vector
     *
     * @param string $au Authentication Value [M,S,N]
     */
    public function setAu($au)
    {
        switch ($au) {
            case 'M':
                $this->_baseVector['Au'] = 'M';
                $this->_BaseVectorLabel['Au'] = 'Multiple Instance';
                $this->_baseAuthValues = self::$authenticationValues['multiple_instance'];
                break;
            case 'S':
                $this->_baseVector['Au'] = 'S';
                $this->_baseVectorLabels['Au'] = 'Single Instance';
                $this->_baseAuthValues = self::$authenticationValues['single_instance'];
                break;
            case 'N':
                $this->_baseVector['Au'] = 'N';
                $this->_baseVectorLabels['Au'] = 'None';
                $this->_baseAuthValues = self::$authenticationValues['none'];
                break;
            default:
                throw new Fisma_Zend_Exception('Failed to set Authentication Values');
                break;
        }
    }

    /**
     * Gets the Authentication Value (Au)
     *
     * @return float
     */
    public function getAu()
    {
        return $this->_baseAuthValues;
    }

    /**
     * Sets the Confidentiality Impact (C) value and vector
     *
     * @param string $c Confidentiality Impact [N,P,C]
     */
    public function setC($c)
    {
        switch ($c) {
            case 'N':
                $this->_baseVector['C'] = 'N';
                $this->_baseVectorLabels['C'] = 'None';
                $this->_baseConfImpact = self::$confidentialityImpactValues['none'];
                break;
            case 'P':
                $this->_baseVector['C'] = 'P';
                $this->_baseVectorLabels['C'] = 'Partial';
                $this->_baseConfImpact = self::$confidentialityImpactValues['partial'];
                break;
            case 'C':
                $this->_baseVector['C'] = 'C';
                $this->_baseVectorLabels['C'] = 'Complete';
                $this->_baseConfImpact = self::$confidentialityImpactValues['complete'];
                break;
            default:
                throw new Fisma_Zend_Exception('Failed to set Confidentiality Impact');
                break;
        }
    }

    /**
     * Gets the Confidentiality Impact (C) value
     *
     * @return float
     */
    public function getC()
    {
        return $this->_baseConfImpact;
    }

    /**
     * Sets the Integrity Impact (I) value and vector
     *
     * @param string $i Integrity Impact [N,P,C]
     */
    public function setI($i)
    {
        switch ($i) {
            case 'N':
                $this->_baseVector['I'] = 'N';
                $this->_baseVectorLabels['I'] = 'None';
                $this->_baseIntegImpact = self::$integrityImpactValues['none'];
                break;
            case 'P':
                $this->_baseVector['I'] = 'P';
                $this->_baseVectorLabels['I'] = 'Partial';
                $this->_baseIntegImpact = self::$integrityImpactValues['partial'];
                break;
            case 'C':
                $this->_baseVector['I'] = 'C';
                $this->_baseVectorLabels['I'] = 'Complete';
                $this->_baseIntegImpact = self::$integrityImpactValues['complete'];
                break;
            default:
                throw new Fisma_Zend_Exception('Failed to set Integrity Impact');
                break;
        }
    }

    /**
     * Gets the Integrity Impact (I) value
     *
     * @return float
     */
    public function getI()
    {
        return $this->_baseIntegImpact;
    }

    /**
     * Sets the Availability Impact (A) value and vector
     *
     * @param string $a Availability Impact [N,P,C]
     */
    public function setA($a)
    {
        switch ($a) {
            case 'N':
                $this->_baseVector['A'] = 'N';
                $this->_baseVectorLabels['A'] = 'None';
                $this->_baseAvailImpact = self::$availabilityImpactValues['none'];
                break;
            case 'P':
                $this->_baseVector['A'] = 'P';
                $this->_baseVectorLabels['A'] = 'Partial';
                $this->_baseAvailImpact = self::$availabilityImpactValues['partial'];
                break;
            case 'C':
                $this->_baseVector['A'] = 'C';
                $this->_baseVectorLabels['A'] = 'Complete';
                $this->_baseAvailImpact = self::$availabilityImpactValues['complete'];
                break;
            default:
                throw new Fisma_Zend_Exception('Failed to set Availability Impact');
                break;
        }
    }

    /**
     * Gets the Availability Impact (A) value
     *
     * @return float
     */
    public function getA()
    {
        return $this->_baseAvailImpact;
    }

    /**
     * Sets the Exploitability Values (EX) value and vector
     *
     * @param string $e Exploitability Values [U,POC,F,N,ND]
     */
    public function setE($e = 'ND')
    {
        switch($e) {
            case 'U':
                $this->_temporalVector['E'] = 'U';
                $this->_temporalExploitability = self::$exploitabilityValues['unproven'];
                break;
            case 'POC':
                $this->_temporalVector['E'] = 'POC';
                $this->_temporalExploitability = self::$exploitabilityValues['proof_of_concept'];
                break;
            case 'F':
                $this->_temporalVector['E'] = 'F';
                $this->_temporalExploitability = self::$exploitabilityValues['functional'];
                break;
            case 'H':
                $this->_temporalVector['E'] = 'H';
                $this->_temporalExploitability = self::$exploitabilityValues['high'];
                break;
            case 'ND':
                $this->_temporalVector['E'] = 'ND';
                $this->_temporalExploitability = self::$exploitabilityValues['not_defined'];
                break;
            default:
                throw new Fisma_Zend_Exception('Failed to set Exploitability Values');
                break;
        }
    }

    /**
     * Gets the Exploitability Values (EX) value
     *
     * @return float
     */
    public function getE()
    {
        return $this->_temporalExploitability;
    }

    /**
     * Sets Remediation Levels (RL) value and vector
     *
     * @param string $rl Remediation Levels [OF,TF,W,U,ND]
     */
    public function setRL($rl = 'ND')
    {
        switch ($rl) {
            case 'OF':
                $this->_temporalVector['RL'] = 'OF';
                $this->_temporalRemediationLevel = self::$remediationLevelValues['official_fix'];
                break;
            case 'TF':
                $this->_temporalVector['RL'] = 'TF';
                $this->_temporalRemediationLevel = self::$remediationLevelValues['temporary_fix'];
                break;
            case 'W':
                $this->_temporalVector['RL'] = 'W';
                $this->_temporalRemediationLevel = self::$remediationLevelValues['workaround'];
                break;
            case 'U':
                $this->_temporalVector['RL'] = 'U';
                $this->_temporalRemediationLevel = self::$remediationLevelValues['unavailable]'];
                break;
            case 'ND':
                $this->_temporalVector['RL'] = 'ND';
                $this->_temporalRemediationLevel = self::$remediationLevelValues['not_defined'];
                break;
            default:
                throw new Fisma_Zend_Exception('Failed to set Remediation Levels');
                break;
        }
    }

    /**
     * Gets Remediation Levels (RL) value
     *
     * @return float
     */
    public function getRL()
    {
        return $this->_temporalRemediationLevel;
    }

    /**
     * Sets Report Confidence (RC) value and vector
     *
     * @param string $rc Report Confidence [UC,UR,C,ND]
     */
    public function setRC($rc = 'ND')
    {
        switch ($rc) {
            case 'UC':
                $this->_temporalVector['RC'] = 'UC';
                $this->_temporalReportConfidence = self::$reportConfidenceValues['unconfirmed'];
                break;
            case 'UR':
                $this->_temporalVector['RC'] = 'UR';
                $this->_temporalReportConfidence = self::$reportConfidenceValues['uncorroborated'];
                break;
            case 'C':
                $this->_temporalVector['RC'] = 'C';
                $this->_temporalReportConfidence = self::$reportConfidenceValues['confirmed'];
                break;
            case 'ND':
                $this->_temporalVector['RC'] = 'ND';
                $this->_temporalReportConfidence = self::$reportConfidenceValues['not_defined'];
                break;
            default:
                throw new Fisma_Zend_Exception('Failed to set Report Confidence');
                break;
        }
    }

    /**:
     * Gets Report Confidence (RC) value
     *
     * @return float
     */
    public function getRC()
    {
        return $this->_temporalReportConfidence;
    }

    /**
     * Sets the Collateral Damage Potential (CDP) value and vector
     *
     * @param string [N,L,LM,MH,H,ND]
     */
    public function setCDP($cdp = 'ND')
    {
        switch ($cdp) {
            case 'N':
                $this->_environmentalVector['CDP'] = 'N';
                $this->_envCollateralDamage = self::$collateralDamageValues['none'];
                break;
            case 'L':
                $this->_environmentalVector['CDP'] = 'L';
                $this->_envCollateralDamage = self::$collateralDamageValues['low'];
                break;
            case 'LM':
                $this->_environmentalVector['CDP'] = 'LM';
                $this->_envCollateralDamage = self::$collateralDamageValues['low_medium'];
                break;
            case 'MH':
                $this->_environmentalVector['CDP'] = 'MH';
                $this->_envCollateralDamage = self::$collateralDamageValues['medium_high'];
                break;
            case 'H':
                $this->_environmentalVector['CDP'] = 'H';
                $this->_envCollateralDamage = self::$collateralDamageValues['high'];
                break;
            case 'ND':
                $this->_environmentalVector['CDP'] = 'ND';
                $this->_envCollateralDamage = self::$collateralDamageValues['not_defined'];
                break;
            default:
                throw new Fisma_Zend_Exception('Failed to set Collateral Damage');
                break;
        }
    }

    /**
     * Gets the Collateral Damage Potential (CDP) value
     *
     * @return float
     */
    public function getCDP()
    {
        return $this->_envCollateralDamage;
    }

    /**
     * Sets the Target Distribution (TD) value and vector
     *
     * @param string $td Target Distribution [N,L,M,H,ND]
     */
    public function setTD($td = 'ND')
    {
        switch ($td) {
            case 'N':
                $this->_environmentalVector['TD'] = 'N';
                $this->_envTargetDist = self::$targetDistributionValues['none'];
                break;
            case 'L':
                $this->_environmentalVector['TD'] = 'L';
                $this->_envTargetDist = self::$targetDistributionValues['low'];
                break;
            case 'M':
                $this->_environmentalVector['TD'] = 'M';
                $this->_envTargetDist = self::$targetDistributionValues['medium'];
                break;
            case 'H':
                $this->_environmentalVector['TD'] = 'H';
                $this->_envTargetDist = self::$targetDistributionValues['high'];
                break;
            case 'ND':
                $this->_environmentalVector['TD'] = 'ND';
                $this->_envTargetDist = self::$targetDistributionValues['not_defined'];
                break;
            default:
              throw new Fisma_Zend_Exception('Failed to set Target Distribution');
        }
    }

    /**
     * Gets the Target Distribution (TD) value
     *
     * @return float
     */
    public function getTD()
    {
        return $this->_envTargetDist;
    }

    /**
     * Sets the Confidentiality Requirement (CR) value and vector
     *
     * @param string $cr Confidentiality Requirement [L,M,H,ND]
     */
    public function setCR($cr = 'ND')
    {
        switch ($cr) {
            case 'L':
                $this->_environmentalVector['CR'] = 'L';
                $this->_envConfReq = self::$confidentialityRequirementValues['low'];
                break;
            case 'M':
                $this->_environmentalVector['CR'] = 'M';
                $this->_envConfReq = self::$confidentialityRequirementValues['medium'];
                break;
            case 'H':
                $this->_environmentalVector['CR'] = 'H';
                $this->_envConfReq = self::$confidentialityRequirementValues['high'];
                break;
            case 'ND':
                $this->_environmentalVector['CR'] = 'ND';
                $this->_envConfReq = self::$confidentialityRequirementValues['not_defined'];
                break;
            default:
                throw new Fisma_Zend_Exception('Failed to set Confidentiality Requirement');
                break;
        }
    }

    /**
     * Gets the Confidentiality Requirement (CR) value
     *
     * @return float
     */
    public function getCR()
    {
        return $this->_envConfReq;
    }

    /**
     * Sets the Integrity Requirement (IR) value and vector
     *
     * @param string $ir Integrity Requirement [L,M,H,ND]
     */
    public function setIR($ir = 'ND')
    {
        //Integrity Requirement
        switch ($ir) {
            case 'L':
                $this->_environmentalVector['IR'] = 'L';
                $this->_envIntegReq = self::$integrityRequirementValues['low'];
                break;
            case 'M':
                $this->_environmentalVector['IR'] = 'M';
                $this->_envIntegReq = self::$integrityRequirementValues['medium'];
                break;
            case 'H':
                $this->_environmentalVector['IR'] = 'H';
                $this->_envIntegReq = self::$integrityRequirementValues['high'];
                break;
            case 'ND':
                $this->_environmentalVector['IR'] = 'ND';
                $this->_envIntegReq = self::$integrityRequirementValues['not_defined'];
                break;
            default:
                throw new Fisma_Zend_Exception('Failed to set Integrity Requirement');
                break;
        }
    }

    /**
     * Gets the Integrity Requirement (IR) value
     *
     * @return float
     */
    public function getIR()
    {
        return $this->_envIntegReq;
    }

    /**
     * Set Availability Requirement (AR) value and vector
     *
     * @param string $ar Availability Requirement [L,M,H,ND]
     */
    public function setAR($ar = 'ND')
    {
        switch ($ar) {
            case 'L':
                $this->_environmentalVector['AR'] = 'L';
                $this->_envAvailReq = self::$availabilityRequirementValues['low'];
                break;
            case 'M':
                $this->_environmentalVector['AR'] = 'M';
                $this->_envAvailReq = self::$availabilityRequirementValues['medium'];
                break;
            case 'H':
                $this->_environmentalVector['AR'] = 'H';
                $this->_envAvailReq = self::$availabilityRequirementValues['high'];
                break;
            case 'ND':
                $this->_environmentalVector['AR'] = 'ND';
                $this->_envAvailReq = self::$availabilityRequirementValues['not_defined'];
                break;
            default:
                throw new Fisma_Zend_Exception('Failed to set Availability Requirement');
                break;
        }
    }

    /**
     * Get Availability Requirement (AR)
     *
     * @return float
     */
    public function getAR()
    {
        return $this->_envAvailReq;
    }

    /**
     * Sets the Base Score after being calculated
     *
     * @paramn float
     */
    public function setBaseScore($baseScoreCalculated)
    {
        $this->_baseScoreResult = $baseScoreCalculated;
    }

    /**
     * Gets the Base Score after being calculated
     *
     * @return float
     */
    public function getBaseScore()
    {
        return $this->_baseScoreResult;
    }

    /**
     * Sets the Impact Score after being calculated
     *
     * @param float
     */
    public function setImpactScore($impactScoreCalculated)
    {
        $this->_impactScoreResult = $impactScoreCalculated;
    }

    /**
     * Gets the Impact Score after being calculated
     *
     * @return float
     */
    public function getImpactScore()
    {
        return $this->_impactScoreResult;
    }

    /**
     * Sets the Exploitability Score after being calculated
     *
     * @param float
     */
    public function setExploitabilityScore($exploitabilityScoreCalculated)
    {
        $this->_exploitabilityScoreResult = $exploitabilityScoreCalculated;
    }

    /**
     * Gets the Exploitability Score after being calculated
     *
     * @return float
     */
    public function getExploitabilityScore()
    {
        return $this->_exploitabilityScoreResult;
    }

    /**
     * Sets the Temporal Score after being calculated
     *
     * @paramr float
     */
    public function setTemporalScore($temporalScoreCalculated)
    {
        $this->_temporalScoreResult = $temporalScoreCalculated;
    }

    /**a
     * Gets the Temporal Score after being calculated
     *
     * @return float
     */
    public function getTemporalScore()
    {
        return $this->_temporalScoreResult;
    }

    /**
     * Set Environmental Score
     *
     * @param float
     */
    public function setEnvironmentalScore($environmentalScoreCalculated)
    {
        $this->_environmentalScoreResult = $environmentalScoreCalculated;
    }

    /**
     * Get Environmental Score
     *
     * @returnr float
     */
    public function getEnvironmentalScore()
    {
        return $this->_environmentalScoreResult;
    }

    /**
     * Set Adjusted Base Score
     *
     * @param float
     */
    public function setAdjustedBaseScore($adjustedBaseScoreCalculated)
    {
        $this->_adjustedBaseScoreResult = $adjustedBaseScoreCalculated;
    }

    /**
     * Get Adjusted Base Score
     *
     * @return float
     */
    public function getAdjustedBaseScore()
    {
        return $this->_adjustedBaseScoreResult;
    }

    /**
     * Set Availability Requirement (AR)
     *
     * @param float
     */
    public function setAdjustedImpactScore($adjustedImpactScoreCalculated)
    {
        $this->_adjustedImpactScoreResult = $adjustedImpactScoreCalculated;
    }

    /**
     * Get Availability Requirement (AR)
     *
     * @return float
     */
    public function getAdjustedImpactScore()
    {
        return $this->_adjustedImpactScoreResult;
    }

    /**
     * Set Adjusted Temporal Score
     *
     * @param float
     */
    public function setAdjustedTemporalScore($adjustedTemporalScoreCalculated)
    {
        $this->_adjustedTemporalScoreResult = $adjustedTemporalScoreCalculated;
    }

    /**
     * Get Adjusted Temporal Score
     *
     * @return float
     */
    public function getAdjustedTemporalScore()
    {
        return $this->_adjustedTemporalScoreResult;
    }

    /**
     * Calculate all the values that were defined in the scores function
     */
    public function calculate()
    {
        $this->calcImpactScore();
        $this->calcExploitabilityScore();
        $this->calcBaseScore();
        $this->calcTemporalScore();
        $this->calcEnvironmentalScore();
    }

    /**
     * Calculates Base Score and calls setBaseScore
     * BaseScore = round_to_1_decimal(((0.6*Impact)+(0.4*Exploitability)-1.5)*f(Impact))
     */
    public function calcBaseScore()
    {
        $av = $this->getAV();
        $ac = $this->getAC();
        $au = $this->getAu();

        $impactScoreResult = $this->getImpactScore();
        $exploitabilityScoreResult = $this->getExploitabilityScore();
        $impact = $this->decideImpact($impactScoreResult);

        $baseScoreCalculated = round(
            ((0.6 * $impactScoreResult) +
            (0.4 * $exploitabilityScoreResult) - 1.5) * $impact, 1
        );
        $this->setBaseScore($baseScoreCalculated);
    }

    /**
     * Impact = 10.41*(1-(1-ConfImpact)(1-IntegImpact)*(1-AvailImpact))
     */
    public function calcImpactScore()
    {
        $c = $this->getC();
        $i = $this->getI();
        $a = $this->getA();
        //Added a round
        $impactScoreCalculated = round(
            10.41 * (1 - (1 - $c) * (1 - $i) * (1 - $a)), 1
        );
        $this->setImpactScore($impactScoreCalculated);
    }

    /**
     * Exploitability = 20* AccessVector*AccessComplexity*Authentication
     */
    public function calcExploitabilityScore()
    {
        $av = $this->getAV();
        $ac = $this->getAC();
        $au = $this->getAu();

        $exploitabilityScoreCalculated = round(
            (20 * $av * $ac * $au), 1
        );
        $this->setExploitabilityScore($exploitabilityScoreCalculated);
    }

    /**
     * TemporalScore = round_to_1_decimal(BaseScore*Exploitability*RemediationLevel*ReportConfidence)
     */
    public function calcTemporalScore()
    {
        $e = $this->getE();
        $rl = $this->getRL();
        $rc = $this->getRC();
        $baseScoreResult = $this->getBaseScore();
        $temporalScoreCalculated = round(
            $baseScoreResult * $e * $rl * $rc, 1
        );

        if ($temporalScoreCalculated == 0) {
            $temporalScoreCalculated = 'Undefined';
        }
            $this->setTemporalScore($temporalScoreCalculated);
    }

    /**
     * EnvironmentalScore = round_to_1_decimal((AdjustedTemporal+(10-AdjustedTemporal)
     *                      *CollateralDamagePotential)*TargetDistribution)
     */
    public function calcEnvironmentalScore()
    {
        $cdp = $this->getCDP();
        $td = $this->getTD();

        $this->calcAdjustedImpactScore(); //impact first
        $this->calcAdjustedBaseScore(); //base second (exploitability does not change)
        $this->calcAdjustedTemporalScore(); //temporal third
        $adjustedTemporalScoreResult = $this->getAdjustedTemporalScore();
        $environmentalScoreCalculated = round(
            ($adjustedTemporalScoreResult +
            (10 - $adjustedTemporalScoreResult) * $cdp) * $td, 1
        );

        if ($environmentalScoreCalculated == 0) {
            $environmentalScoreCalculated = 'Undefined';
        }
            $this->setEnvironmentalScore($environmentalScoreCalculated);
    }

    /**
     * Calculates the AdjustedBaseScore and then calls setAdjustedBaseScore
     * AdjustedBase =((0.6*10)+(0.4*10.0)1.5)*1.176
     */
    public function calcAdjustedBaseScore()
    {
        $adjustedImpactScoreResult = $this->getAdjustedImpactScore();
        $exploitabilityScoreResult = $this->getExploitabilityScore();
        $impact = $this->decideImpact($adjustedImpactScoreResult);
        $adjustedBaseScoreCalculated = round(
            ((0.6 * $adjustedImpactScoreResult +
            (0.4 * $exploitabilityScoreResult-1.5) * $impact)), 1
        );
        $this->setAdjustedBaseScore($adjustedBaseScoreCalculated);
    }

    /**
     * Calculates the AdjustedImpactScore and then calls setAdjustedImpactScore
     * AdjustedImpact = min(10,10.41*(1-(1-ConfImpact*ConfReq)*(1-IntegImpact*IntegReq)
     *                  *(1-AvailImpact*AvailReq)))
     */
    public function calcAdjustedImpactScore()
    {
        $c = $this->getC();
        $i = $this->getI();
        $a = $this->getA();
        $cr = $this->getCR();
        $ir = $this->getIR();
        $ar = $this->getAR();

        $adjustedImpactScoreCalculated = min(
            10, 10.41 * (1 - (1 - $c * $cr) *
            (1 - $i * $ir) * (1 - $a * $ar))
        );
        $this->setAdjustedImpactScore($adjustedImpactScoreCalculated);
    }

    /**
     * AdjustedTemporal = TemporalScore recomputed with the BaseScores Impact sub-equation
     * replaced with the AdjustedImpact equation
     */
    public function calcAdjustedTemporalScore()
    {
        $e = $this->getE();
        $rl = $this->getRL();
        $rc = $this->getRC();

        $adjustedBaseScoreResult = $this->getBaseScore();
        $adjustedTemporalScoreCalculated = $adjustedBaseScoreResult * $e * $rl * $rc;
        $this->setAdjustedTemporalScore($adjustedTemporalScoreCalculated);
    }

    /**
     * Determines Impact
     * f(impact)= 0 if Impact=0, 1.176 otherwise
     */
    public function decideImpact($anyImpactScore)
    {
        if ($anyImpactScore == 0) {
            $impact = 0;
        } else {
            $impact = 1.176;
        }

        return $impact;
    }

    /**
     * Parse Vector string for key/values and call setter methods
     */
    public function parseVector($string)
    {
        $match = '#^AV:[LAN]/AC:[HML]/Au:[MSN]/C:[NPC]/I:[NPC]/A:[NPC]
            (/E:([UFH]|ND|POC)/RL:([WU]|OF|TF)/RC:(UC|UR|C|ND))?#x';
        if (preg_match($match, $string)) {
            //Default Temporal and Environmental to Not Defined (ND)
            $vectors = array('E' => 'ND',
                            'RL' => 'ND',
                            'RC' => 'ND',
                            'CDP' => 'ND',
                            'TD' => 'ND',
                            'CR' => 'ND',
                            'IR' => 'ND',
                            'AR' => 'ND',
                        );

            //Break K:V Vector divided by /'s into an assoc array
            foreach (explode('/', $string) as $split) {
                list($k,$v) = explode(':', $split);
                $vectors[strtoupper($k)] = strtoupper($v);
            }
            
            //Base
            $this->setAV($vectors['AV']);
            $this->setAC($vectors['AC']);
            $this->setAu($vectors['AU']);
            $this->setC($vectors['C']);
            $this->setI($vectors['I']);
            $this->setA($vectors['A']);
            //Temporal
            $this->setE($vectors['E']);
            $this->setRL($vectors['RL']);
            $this->setRC($vectors['RC']);
            //Environmental
            $this->setCDP($vectors['CDP']);
            $this->setTD($vectors['TD']);
            $this->setCR($vectors['CR']);
            $this->setIR($vectors['IR']);
            $this->setAR($vectors['AR']);
            return 1;
        } else {
            return 0;
        }
    }

    /*
     * Used by array_walk to construct vector key:value
     */
    private function _constructVector(&$v, $k)
    {
        $v = "$k:$v";
    }

    /*
     * Gets the Base Vector
     *
     * @return string
     */
    public function getBaseVector()
    {
        $baseVector = $this->_baseVector;
        array_walk($baseVector, array($this, '_constructVector'));
        return implode($baseVector, "/");
    }

    /*
     * Gets the Base Vector Array
     *
     * @return array
     */
    public function getBaseVectorArray()
    {
        return $this->_baseVector;
    }

    /*
     * Gets the Temporal Vector
     *
     * @return string
     */
    public function getTemporalVector()
    {
        $temporalVector = $this->_temporalVector;
        array_walk($temporalVector, array($this, '_constructVector'));
        return implode($temporalVector, "/");
    }

    /*
     * Gets the Temporal Vector Array
     *
     * @return array
     */
    public function getTemporalVectorArray()
    {
        return $this->_temporalVector;
    }

    /*
     * Gets the Environmental Vector
     *
     * @return string
     */
    public function getEnvironmentalVector()
    {
        $environmentalVector = $this->_environmentalVector;
        array_walk($environmentalVector, array($this, '_constructVector'));
        return implode($environmentalVector, "/");
    }

    /*
     * Gets the Environmental Vector Array
     *
     * @return array
     */
    public function getEnvironmentalVectorArray()
    {
        return $this->_environmentalVector;
    }

    /*
     * Gets the Base, Temporal and Environmental Vectors
     *
     * @return string
     */
    public function getVector()
    {
        return $this->getBaseVector() . '/' .
               $this->getTemporalVector() . '/' .
               $this->getEnvironmentalVector();
    }

    /*
     * Gets array of set Base Vector value names
     *
     * @return array
     */
    public function getBaseVectorLabels()
    {
        return $this->_baseVectorLabels;
    }

    /*
     * Returns string of all vectors
     *
     * @return string
     */
    public function __toString()
    {
        return $this->getVector();
    }
}
